Conflict in state 124 between rule 49 and token ASSIGN resolved as reduce.
Conflict in state 124 between rule 49 and token '=' resolved as reduce.
Conflict in state 124 between rule 49 and token '?' resolved as reduce.
Conflict in state 124 between rule 49 and token OROR resolved as reduce.
Conflict in state 124 between rule 49 and token ANDAND resolved as reduce.
Conflict in state 124 between rule 49 and token '|' resolved as reduce.
Conflict in state 124 between rule 49 and token '^' resolved as reduce.
Conflict in state 124 between rule 49 and token '&' resolved as reduce.
Conflict in state 124 between rule 49 and token EQCOMPARE resolved as reduce.
Conflict in state 124 between rule 49 and token ARITHCOMPARE resolved as reduce.
Conflict in state 124 between rule 49 and token LSHIFT resolved as reduce.
Conflict in state 124 between rule 49 and token RSHIFT resolved as reduce.
Conflict in state 124 between rule 49 and token '+' resolved as reduce.
Conflict in state 124 between rule 49 and token '-' resolved as reduce.
Conflict in state 124 between rule 49 and token '*' resolved as reduce.
Conflict in state 124 between rule 49 and token '/' resolved as reduce.
Conflict in state 124 between rule 49 and token '%' resolved as reduce.
Conflict in state 126 between rule 51 and token ASSIGN resolved as reduce.
Conflict in state 126 between rule 51 and token '=' resolved as reduce.
Conflict in state 126 between rule 51 and token '?' resolved as reduce.
Conflict in state 126 between rule 51 and token OROR resolved as reduce.
Conflict in state 126 between rule 51 and token ANDAND resolved as reduce.
Conflict in state 126 between rule 51 and token '|' resolved as reduce.
Conflict in state 126 between rule 51 and token '^' resolved as reduce.
Conflict in state 126 between rule 51 and token '&' resolved as reduce.
Conflict in state 126 between rule 51 and token EQCOMPARE resolved as reduce.
Conflict in state 126 between rule 51 and token ARITHCOMPARE resolved as reduce.
Conflict in state 126 between rule 51 and token LSHIFT resolved as reduce.
Conflict in state 126 between rule 51 and token RSHIFT resolved as reduce.
Conflict in state 126 between rule 51 and token '+' resolved as reduce.
Conflict in state 126 between rule 51 and token '-' resolved as reduce.
Conflict in state 126 between rule 51 and token '*' resolved as reduce.
Conflict in state 126 between rule 51 and token '/' resolved as reduce.
Conflict in state 126 between rule 51 and token '%' resolved as reduce.
Conflict in state 127 between rule 45 and token ASSIGN resolved as reduce.
Conflict in state 127 between rule 45 and token '=' resolved as reduce.
Conflict in state 127 between rule 45 and token '?' resolved as reduce.
Conflict in state 127 between rule 45 and token OROR resolved as reduce.
Conflict in state 127 between rule 45 and token ANDAND resolved as reduce.
Conflict in state 127 between rule 45 and token '|' resolved as reduce.
Conflict in state 127 between rule 45 and token '^' resolved as reduce.
Conflict in state 127 between rule 45 and token '&' resolved as reduce.
Conflict in state 127 between rule 45 and token EQCOMPARE resolved as reduce.
Conflict in state 127 between rule 45 and token ARITHCOMPARE resolved as reduce.
Conflict in state 127 between rule 45 and token LSHIFT resolved as reduce.
Conflict in state 127 between rule 45 and token RSHIFT resolved as reduce.
Conflict in state 127 between rule 45 and token '+' resolved as reduce.
Conflict in state 127 between rule 45 and token '-' resolved as reduce.
Conflict in state 127 between rule 45 and token '*' resolved as reduce.
Conflict in state 127 between rule 45 and token '/' resolved as reduce.
Conflict in state 127 between rule 45 and token '%' resolved as reduce.
Conflict in state 132 between rule 46 and token ASSIGN resolved as reduce.
Conflict in state 132 between rule 46 and token '=' resolved as reduce.
Conflict in state 132 between rule 46 and token '?' resolved as reduce.
Conflict in state 132 between rule 46 and token OROR resolved as reduce.
Conflict in state 132 between rule 46 and token ANDAND resolved as reduce.
Conflict in state 132 between rule 46 and token '|' resolved as reduce.
Conflict in state 132 between rule 46 and token '^' resolved as reduce.
Conflict in state 132 between rule 46 and token '&' resolved as reduce.
Conflict in state 132 between rule 46 and token EQCOMPARE resolved as reduce.
Conflict in state 132 between rule 46 and token ARITHCOMPARE resolved as reduce.
Conflict in state 132 between rule 46 and token LSHIFT resolved as reduce.
Conflict in state 132 between rule 46 and token RSHIFT resolved as reduce.
Conflict in state 132 between rule 46 and token '+' resolved as reduce.
Conflict in state 132 between rule 46 and token '-' resolved as reduce.
Conflict in state 132 between rule 46 and token '*' resolved as reduce.
Conflict in state 132 between rule 46 and token '/' resolved as reduce.
Conflict in state 132 between rule 46 and token '%' resolved as reduce.
Conflict in state 216 between rule 69 and token ASSIGN resolved as shift.
Conflict in state 216 between rule 69 and token '=' resolved as shift.
Conflict in state 216 between rule 69 and token '?' resolved as shift.
Conflict in state 216 between rule 69 and token OROR resolved as shift.
Conflict in state 216 between rule 69 and token ANDAND resolved as shift.
Conflict in state 216 between rule 69 and token '|' resolved as shift.
Conflict in state 216 between rule 69 and token '^' resolved as shift.
Conflict in state 216 between rule 69 and token '&' resolved as shift.
Conflict in state 216 between rule 69 and token EQCOMPARE resolved as shift.
Conflict in state 216 between rule 69 and token ARITHCOMPARE resolved as shift.
Conflict in state 216 between rule 69 and token LSHIFT resolved as shift.
Conflict in state 216 between rule 69 and token RSHIFT resolved as shift.
Conflict in state 216 between rule 69 and token '+' resolved as shift.
Conflict in state 216 between rule 69 and token '-' resolved as shift.
Conflict in state 216 between rule 69 and token '*' resolved as shift.
Conflict in state 216 between rule 69 and token '/' resolved as shift.
Conflict in state 216 between rule 69 and token '%' resolved as shift.
Conflict in state 217 between rule 68 and token ASSIGN resolved as shift.
Conflict in state 217 between rule 68 and token '=' resolved as shift.
Conflict in state 217 between rule 68 and token '?' resolved as shift.
Conflict in state 217 between rule 68 and token OROR resolved as shift.
Conflict in state 217 between rule 68 and token ANDAND resolved as shift.
Conflict in state 217 between rule 68 and token '|' resolved as shift.
Conflict in state 217 between rule 68 and token '^' resolved as shift.
Conflict in state 217 between rule 68 and token '&' resolved as shift.
Conflict in state 217 between rule 68 and token EQCOMPARE resolved as shift.
Conflict in state 217 between rule 68 and token ARITHCOMPARE resolved as shift.
Conflict in state 217 between rule 68 and token LSHIFT resolved as shift.
Conflict in state 217 between rule 68 and token RSHIFT resolved as shift.
Conflict in state 217 between rule 68 and token '+' resolved as shift.
Conflict in state 217 between rule 68 and token '-' resolved as shift.
Conflict in state 217 between rule 68 and token '*' resolved as shift.
Conflict in state 217 between rule 68 and token '/' resolved as shift.
Conflict in state 217 between rule 68 and token '%' resolved as shift.
Conflict in state 220 between rule 66 and token ASSIGN resolved as reduce.
Conflict in state 220 between rule 66 and token '=' resolved as reduce.
Conflict in state 220 between rule 66 and token '?' resolved as reduce.
Conflict in state 220 between rule 66 and token OROR resolved as reduce.
Conflict in state 220 between rule 66 and token ANDAND resolved as shift.
Conflict in state 220 between rule 66 and token '|' resolved as shift.
Conflict in state 220 between rule 66 and token '^' resolved as shift.
Conflict in state 220 between rule 66 and token '&' resolved as shift.
Conflict in state 220 between rule 66 and token EQCOMPARE resolved as shift.
Conflict in state 220 between rule 66 and token ARITHCOMPARE resolved as shift.
Conflict in state 220 between rule 66 and token LSHIFT resolved as shift.
Conflict in state 220 between rule 66 and token RSHIFT resolved as shift.
Conflict in state 220 between rule 66 and token '+' resolved as shift.
Conflict in state 220 between rule 66 and token '-' resolved as shift.
Conflict in state 220 between rule 66 and token '*' resolved as shift.
Conflict in state 220 between rule 66 and token '/' resolved as shift.
Conflict in state 220 between rule 66 and token '%' resolved as shift.
Conflict in state 221 between rule 65 and token ASSIGN resolved as reduce.
Conflict in state 221 between rule 65 and token '=' resolved as reduce.
Conflict in state 221 between rule 65 and token '?' resolved as reduce.
Conflict in state 221 between rule 65 and token OROR resolved as reduce.
Conflict in state 221 between rule 65 and token ANDAND resolved as reduce.
Conflict in state 221 between rule 65 and token '|' resolved as shift.
Conflict in state 221 between rule 65 and token '^' resolved as shift.
Conflict in state 221 between rule 65 and token '&' resolved as shift.
Conflict in state 221 between rule 65 and token EQCOMPARE resolved as shift.
Conflict in state 221 between rule 65 and token ARITHCOMPARE resolved as shift.
Conflict in state 221 between rule 65 and token LSHIFT resolved as shift.
Conflict in state 221 between rule 65 and token RSHIFT resolved as shift.
Conflict in state 221 between rule 65 and token '+' resolved as shift.
Conflict in state 221 between rule 65 and token '-' resolved as shift.
Conflict in state 221 between rule 65 and token '*' resolved as shift.
Conflict in state 221 between rule 65 and token '/' resolved as shift.
Conflict in state 221 between rule 65 and token '%' resolved as shift.
Conflict in state 222 between rule 63 and token ASSIGN resolved as reduce.
Conflict in state 222 between rule 63 and token '=' resolved as reduce.
Conflict in state 222 between rule 63 and token '?' resolved as reduce.
Conflict in state 222 between rule 63 and token OROR resolved as reduce.
Conflict in state 222 between rule 63 and token ANDAND resolved as reduce.
Conflict in state 222 between rule 63 and token '|' resolved as reduce.
Conflict in state 222 between rule 63 and token '^' resolved as shift.
Conflict in state 222 between rule 63 and token '&' resolved as shift.
Conflict in state 222 between rule 63 and token EQCOMPARE resolved as shift.
Conflict in state 222 between rule 63 and token ARITHCOMPARE resolved as shift.
Conflict in state 222 between rule 63 and token LSHIFT resolved as shift.
Conflict in state 222 between rule 63 and token RSHIFT resolved as shift.
Conflict in state 222 between rule 63 and token '+' resolved as shift.
Conflict in state 222 between rule 63 and token '-' resolved as shift.
Conflict in state 222 between rule 63 and token '*' resolved as shift.
Conflict in state 222 between rule 63 and token '/' resolved as shift.
Conflict in state 222 between rule 63 and token '%' resolved as shift.
Conflict in state 223 between rule 64 and token ASSIGN resolved as reduce.
Conflict in state 223 between rule 64 and token '=' resolved as reduce.
Conflict in state 223 between rule 64 and token '?' resolved as reduce.
Conflict in state 223 between rule 64 and token OROR resolved as reduce.
Conflict in state 223 between rule 64 and token ANDAND resolved as reduce.
Conflict in state 223 between rule 64 and token '|' resolved as reduce.
Conflict in state 223 between rule 64 and token '^' resolved as reduce.
Conflict in state 223 between rule 64 and token '&' resolved as shift.
Conflict in state 223 between rule 64 and token EQCOMPARE resolved as shift.
Conflict in state 223 between rule 64 and token ARITHCOMPARE resolved as shift.
Conflict in state 223 between rule 64 and token LSHIFT resolved as shift.
Conflict in state 223 between rule 64 and token RSHIFT resolved as shift.
Conflict in state 223 between rule 64 and token '+' resolved as shift.
Conflict in state 223 between rule 64 and token '-' resolved as shift.
Conflict in state 223 between rule 64 and token '*' resolved as shift.
Conflict in state 223 between rule 64 and token '/' resolved as shift.
Conflict in state 223 between rule 64 and token '%' resolved as shift.
Conflict in state 224 between rule 62 and token ASSIGN resolved as reduce.
Conflict in state 224 between rule 62 and token '=' resolved as reduce.
Conflict in state 224 between rule 62 and token '?' resolved as reduce.
Conflict in state 224 between rule 62 and token OROR resolved as reduce.
Conflict in state 224 between rule 62 and token ANDAND resolved as reduce.
Conflict in state 224 between rule 62 and token '|' resolved as reduce.
Conflict in state 224 between rule 62 and token '^' resolved as reduce.
Conflict in state 224 between rule 62 and token '&' resolved as reduce.
Conflict in state 224 between rule 62 and token EQCOMPARE resolved as shift.
Conflict in state 224 between rule 62 and token ARITHCOMPARE resolved as shift.
Conflict in state 224 between rule 62 and token LSHIFT resolved as shift.
Conflict in state 224 between rule 62 and token RSHIFT resolved as shift.
Conflict in state 224 between rule 62 and token '+' resolved as shift.
Conflict in state 224 between rule 62 and token '-' resolved as shift.
Conflict in state 224 between rule 62 and token '*' resolved as shift.
Conflict in state 224 between rule 62 and token '/' resolved as shift.
Conflict in state 224 between rule 62 and token '%' resolved as shift.
Conflict in state 225 between rule 61 and token ASSIGN resolved as reduce.
Conflict in state 225 between rule 61 and token '=' resolved as reduce.
Conflict in state 225 between rule 61 and token '?' resolved as reduce.
Conflict in state 225 between rule 61 and token OROR resolved as reduce.
Conflict in state 225 between rule 61 and token ANDAND resolved as reduce.
Conflict in state 225 between rule 61 and token '|' resolved as reduce.
Conflict in state 225 between rule 61 and token '^' resolved as reduce.
Conflict in state 225 between rule 61 and token '&' resolved as reduce.
Conflict in state 225 between rule 61 and token EQCOMPARE resolved as reduce.
Conflict in state 225 between rule 61 and token ARITHCOMPARE resolved as shift.
Conflict in state 225 between rule 61 and token LSHIFT resolved as shift.
Conflict in state 225 between rule 61 and token RSHIFT resolved as shift.
Conflict in state 225 between rule 61 and token '+' resolved as shift.
Conflict in state 225 between rule 61 and token '-' resolved as shift.
Conflict in state 225 between rule 61 and token '*' resolved as shift.
Conflict in state 225 between rule 61 and token '/' resolved as shift.
Conflict in state 225 between rule 61 and token '%' resolved as shift.
Conflict in state 226 between rule 60 and token ASSIGN resolved as reduce.
Conflict in state 226 between rule 60 and token '=' resolved as reduce.
Conflict in state 226 between rule 60 and token '?' resolved as reduce.
Conflict in state 226 between rule 60 and token OROR resolved as reduce.
Conflict in state 226 between rule 60 and token ANDAND resolved as reduce.
Conflict in state 226 between rule 60 and token '|' resolved as reduce.
Conflict in state 226 between rule 60 and token '^' resolved as reduce.
Conflict in state 226 between rule 60 and token '&' resolved as reduce.
Conflict in state 226 between rule 60 and token EQCOMPARE resolved as reduce.
Conflict in state 226 between rule 60 and token ARITHCOMPARE resolved as reduce.
Conflict in state 226 between rule 60 and token LSHIFT resolved as shift.
Conflict in state 226 between rule 60 and token RSHIFT resolved as shift.
Conflict in state 226 between rule 60 and token '+' resolved as shift.
Conflict in state 226 between rule 60 and token '-' resolved as shift.
Conflict in state 226 between rule 60 and token '*' resolved as shift.
Conflict in state 226 between rule 60 and token '/' resolved as shift.
Conflict in state 226 between rule 60 and token '%' resolved as shift.
Conflict in state 227 between rule 58 and token ASSIGN resolved as reduce.
Conflict in state 227 between rule 58 and token '=' resolved as reduce.
Conflict in state 227 between rule 58 and token '?' resolved as reduce.
Conflict in state 227 between rule 58 and token OROR resolved as reduce.
Conflict in state 227 between rule 58 and token ANDAND resolved as reduce.
Conflict in state 227 between rule 58 and token '|' resolved as reduce.
Conflict in state 227 between rule 58 and token '^' resolved as reduce.
Conflict in state 227 between rule 58 and token '&' resolved as reduce.
Conflict in state 227 between rule 58 and token EQCOMPARE resolved as reduce.
Conflict in state 227 between rule 58 and token ARITHCOMPARE resolved as reduce.
Conflict in state 227 between rule 58 and token LSHIFT resolved as reduce.
Conflict in state 227 between rule 58 and token RSHIFT resolved as reduce.
Conflict in state 227 between rule 58 and token '+' resolved as shift.
Conflict in state 227 between rule 58 and token '-' resolved as shift.
Conflict in state 227 between rule 58 and token '*' resolved as shift.
Conflict in state 227 between rule 58 and token '/' resolved as shift.
Conflict in state 227 between rule 58 and token '%' resolved as shift.
Conflict in state 228 between rule 59 and token ASSIGN resolved as reduce.
Conflict in state 228 between rule 59 and token '=' resolved as reduce.
Conflict in state 228 between rule 59 and token '?' resolved as reduce.
Conflict in state 228 between rule 59 and token OROR resolved as reduce.
Conflict in state 228 between rule 59 and token ANDAND resolved as reduce.
Conflict in state 228 between rule 59 and token '|' resolved as reduce.
Conflict in state 228 between rule 59 and token '^' resolved as reduce.
Conflict in state 228 between rule 59 and token '&' resolved as reduce.
Conflict in state 228 between rule 59 and token EQCOMPARE resolved as reduce.
Conflict in state 228 between rule 59 and token ARITHCOMPARE resolved as reduce.
Conflict in state 228 between rule 59 and token LSHIFT resolved as reduce.
Conflict in state 228 between rule 59 and token RSHIFT resolved as reduce.
Conflict in state 228 between rule 59 and token '+' resolved as shift.
Conflict in state 228 between rule 59 and token '-' resolved as shift.
Conflict in state 228 between rule 59 and token '*' resolved as shift.
Conflict in state 228 between rule 59 and token '/' resolved as shift.
Conflict in state 228 between rule 59 and token '%' resolved as shift.
Conflict in state 229 between rule 53 and token ASSIGN resolved as reduce.
Conflict in state 229 between rule 53 and token '=' resolved as reduce.
Conflict in state 229 between rule 53 and token '?' resolved as reduce.
Conflict in state 229 between rule 53 and token OROR resolved as reduce.
Conflict in state 229 between rule 53 and token ANDAND resolved as reduce.
Conflict in state 229 between rule 53 and token '|' resolved as reduce.
Conflict in state 229 between rule 53 and token '^' resolved as reduce.
Conflict in state 229 between rule 53 and token '&' resolved as reduce.
Conflict in state 229 between rule 53 and token EQCOMPARE resolved as reduce.
Conflict in state 229 between rule 53 and token ARITHCOMPARE resolved as reduce.
Conflict in state 229 between rule 53 and token LSHIFT resolved as reduce.
Conflict in state 229 between rule 53 and token RSHIFT resolved as reduce.
Conflict in state 229 between rule 53 and token '+' resolved as reduce.
Conflict in state 229 between rule 53 and token '-' resolved as reduce.
Conflict in state 229 between rule 53 and token '*' resolved as shift.
Conflict in state 229 between rule 53 and token '/' resolved as shift.
Conflict in state 229 between rule 53 and token '%' resolved as shift.
Conflict in state 230 between rule 54 and token ASSIGN resolved as reduce.
Conflict in state 230 between rule 54 and token '=' resolved as reduce.
Conflict in state 230 between rule 54 and token '?' resolved as reduce.
Conflict in state 230 between rule 54 and token OROR resolved as reduce.
Conflict in state 230 between rule 54 and token ANDAND resolved as reduce.
Conflict in state 230 between rule 54 and token '|' resolved as reduce.
Conflict in state 230 between rule 54 and token '^' resolved as reduce.
Conflict in state 230 between rule 54 and token '&' resolved as reduce.
Conflict in state 230 between rule 54 and token EQCOMPARE resolved as reduce.
Conflict in state 230 between rule 54 and token ARITHCOMPARE resolved as reduce.
Conflict in state 230 between rule 54 and token LSHIFT resolved as reduce.
Conflict in state 230 between rule 54 and token RSHIFT resolved as reduce.
Conflict in state 230 between rule 54 and token '+' resolved as reduce.
Conflict in state 230 between rule 54 and token '-' resolved as reduce.
Conflict in state 230 between rule 54 and token '*' resolved as shift.
Conflict in state 230 between rule 54 and token '/' resolved as shift.
Conflict in state 230 between rule 54 and token '%' resolved as shift.
Conflict in state 231 between rule 55 and token ASSIGN resolved as reduce.
Conflict in state 231 between rule 55 and token '=' resolved as reduce.
Conflict in state 231 between rule 55 and token '?' resolved as reduce.
Conflict in state 231 between rule 55 and token OROR resolved as reduce.
Conflict in state 231 between rule 55 and token ANDAND resolved as reduce.
Conflict in state 231 between rule 55 and token '|' resolved as reduce.
Conflict in state 231 between rule 55 and token '^' resolved as reduce.
Conflict in state 231 between rule 55 and token '&' resolved as reduce.
Conflict in state 231 between rule 55 and token EQCOMPARE resolved as reduce.
Conflict in state 231 between rule 55 and token ARITHCOMPARE resolved as reduce.
Conflict in state 231 between rule 55 and token LSHIFT resolved as reduce.
Conflict in state 231 between rule 55 and token RSHIFT resolved as reduce.
Conflict in state 231 between rule 55 and token '+' resolved as reduce.
Conflict in state 231 between rule 55 and token '-' resolved as reduce.
Conflict in state 231 between rule 55 and token '*' resolved as reduce.
Conflict in state 231 between rule 55 and token '/' resolved as reduce.
Conflict in state 231 between rule 55 and token '%' resolved as reduce.
Conflict in state 232 between rule 56 and token ASSIGN resolved as reduce.
Conflict in state 232 between rule 56 and token '=' resolved as reduce.
Conflict in state 232 between rule 56 and token '?' resolved as reduce.
Conflict in state 232 between rule 56 and token OROR resolved as reduce.
Conflict in state 232 between rule 56 and token ANDAND resolved as reduce.
Conflict in state 232 between rule 56 and token '|' resolved as reduce.
Conflict in state 232 between rule 56 and token '^' resolved as reduce.
Conflict in state 232 between rule 56 and token '&' resolved as reduce.
Conflict in state 232 between rule 56 and token EQCOMPARE resolved as reduce.
Conflict in state 232 between rule 56 and token ARITHCOMPARE resolved as reduce.
Conflict in state 232 between rule 56 and token LSHIFT resolved as reduce.
Conflict in state 232 between rule 56 and token RSHIFT resolved as reduce.
Conflict in state 232 between rule 56 and token '+' resolved as reduce.
Conflict in state 232 between rule 56 and token '-' resolved as reduce.
Conflict in state 232 between rule 56 and token '*' resolved as reduce.
Conflict in state 232 between rule 56 and token '/' resolved as reduce.
Conflict in state 232 between rule 56 and token '%' resolved as reduce.
Conflict in state 233 between rule 57 and token ASSIGN resolved as reduce.
Conflict in state 233 between rule 57 and token '=' resolved as reduce.
Conflict in state 233 between rule 57 and token '?' resolved as reduce.
Conflict in state 233 between rule 57 and token OROR resolved as reduce.
Conflict in state 233 between rule 57 and token ANDAND resolved as reduce.
Conflict in state 233 between rule 57 and token '|' resolved as reduce.
Conflict in state 233 between rule 57 and token '^' resolved as reduce.
Conflict in state 233 between rule 57 and token '&' resolved as reduce.
Conflict in state 233 between rule 57 and token EQCOMPARE resolved as reduce.
Conflict in state 233 between rule 57 and token ARITHCOMPARE resolved as reduce.
Conflict in state 233 between rule 57 and token LSHIFT resolved as reduce.
Conflict in state 233 between rule 57 and token RSHIFT resolved as reduce.
Conflict in state 233 between rule 57 and token '+' resolved as reduce.
Conflict in state 233 between rule 57 and token '-' resolved as reduce.
Conflict in state 233 between rule 57 and token '*' resolved as reduce.
Conflict in state 233 between rule 57 and token '/' resolved as reduce.
Conflict in state 233 between rule 57 and token '%' resolved as reduce.
Conflict in state 289 between rule 50 and token '&' resolved as reduce.
Conflict in state 289 between rule 50 and token '+' resolved as reduce.
Conflict in state 289 between rule 50 and token '-' resolved as reduce.
Conflict in state 289 between rule 50 and token '*' resolved as reduce.
Conflict in state 290 between rule 52 and token '&' resolved as reduce.
Conflict in state 290 between rule 52 and token '+' resolved as reduce.
Conflict in state 290 between rule 52 and token '-' resolved as reduce.
Conflict in state 290 between rule 52 and token '*' resolved as reduce.
Conflict in state 295 between rule 47 and token ASSIGN resolved as reduce.
Conflict in state 295 between rule 47 and token '=' resolved as reduce.
Conflict in state 295 between rule 47 and token '?' resolved as reduce.
Conflict in state 295 between rule 47 and token OROR resolved as reduce.
Conflict in state 295 between rule 47 and token ANDAND resolved as reduce.
Conflict in state 295 between rule 47 and token '|' resolved as reduce.
Conflict in state 295 between rule 47 and token '^' resolved as reduce.
Conflict in state 295 between rule 47 and token '&' resolved as reduce.
Conflict in state 295 between rule 47 and token EQCOMPARE resolved as reduce.
Conflict in state 295 between rule 47 and token ARITHCOMPARE resolved as reduce.
Conflict in state 295 between rule 47 and token LSHIFT resolved as reduce.
Conflict in state 295 between rule 47 and token RSHIFT resolved as reduce.
Conflict in state 295 between rule 47 and token '+' resolved as reduce.
Conflict in state 295 between rule 47 and token '-' resolved as reduce.
Conflict in state 295 between rule 47 and token '*' resolved as reduce.
Conflict in state 295 between rule 47 and token '/' resolved as reduce.
Conflict in state 295 between rule 47 and token '%' resolved as reduce.
Conflict in state 366 between rule 67 and token ASSIGN resolved as reduce.
Conflict in state 366 between rule 67 and token '=' resolved as reduce.
Conflict in state 366 between rule 67 and token '?' resolved as shift.
Conflict in state 366 between rule 67 and token OROR resolved as shift.
Conflict in state 366 between rule 67 and token ANDAND resolved as shift.
Conflict in state 366 between rule 67 and token '|' resolved as shift.
Conflict in state 366 between rule 67 and token '^' resolved as shift.
Conflict in state 366 between rule 67 and token '&' resolved as shift.
Conflict in state 366 between rule 67 and token EQCOMPARE resolved as shift.
Conflict in state 366 between rule 67 and token ARITHCOMPARE resolved as shift.
Conflict in state 366 between rule 67 and token LSHIFT resolved as shift.
Conflict in state 366 between rule 67 and token RSHIFT resolved as shift.
Conflict in state 366 between rule 67 and token '+' resolved as shift.
Conflict in state 366 between rule 67 and token '-' resolved as shift.
Conflict in state 366 between rule 67 and token '*' resolved as shift.
Conflict in state 366 between rule 67 and token '/' resolved as shift.
Conflict in state 366 between rule 67 and token '%' resolved as shift.
State 41 contains 1 shift/reduce conflict.
State 90 contains 1 shift/reduce conflict.
State 97 contains 1 shift/reduce conflict.
State 101 contains 1 shift/reduce conflict.
State 117 contains 1 shift/reduce conflict.
State 169 contains 2 shift/reduce conflicts.
State 181 contains 1 shift/reduce conflict.
State 191 contains 1 shift/reduce conflict.
State 197 contains 1 shift/reduce conflict.
State 239 contains 2 shift/reduce conflicts.
State 269 contains 2 shift/reduce conflicts.
State 299 contains 2 shift/reduce conflicts.
State 362 contains 1 shift/reduce conflict.
State 370 contains 2 shift/reduce conflicts.
State 373 contains 2 shift/reduce conflicts.
State 411 contains 2 shift/reduce conflicts.

Grammar
rule 1    program ->		/* empty */
rule 2    program -> extdefs
rule 3    @1 ->		/* empty */
rule 4    extdefs -> @1 extdef
rule 5    @2 ->		/* empty */
rule 6    extdefs -> extdefs @2 extdef
rule 7    extdef -> fndef
rule 8    extdef -> datadef
rule 9    extdef -> ASM '(' string ')' ';'
rule 10   datadef -> setspecs notype_initdecls ';'
rule 11   datadef -> declmods setspecs notype_initdecls ';'
rule 12   datadef -> typed_declspecs setspecs initdecls ';'
rule 13   datadef -> declmods ';'
rule 14   datadef -> typed_declspecs ';'
rule 15   datadef -> error ';'
rule 16   datadef -> error '}'
rule 17   datadef -> ';'
rule 18   @3 ->		/* empty */
rule 19   @4 ->		/* empty */
rule 20   fndef -> typed_declspecs setspecs declarator @3 xdecls @4 compstmt_or_error
rule 21   fndef -> typed_declspecs setspecs declarator error
rule 22   @5 ->		/* empty */
rule 23   @6 ->		/* empty */
rule 24   fndef -> declmods setspecs notype_declarator @5 xdecls @6 compstmt_or_error
rule 25   fndef -> declmods setspecs notype_declarator error
rule 26   @7 ->		/* empty */
rule 27   @8 ->		/* empty */
rule 28   fndef -> setspecs notype_declarator @7 xdecls @8 compstmt_or_error
rule 29   fndef -> setspecs notype_declarator error
rule 30   identifier -> IDENTIFIER
rule 31   identifier -> TYPENAME
rule 32   unop -> '&'
rule 33   unop -> '-'
rule 34   unop -> '+'
rule 35   unop -> PLUSPLUS
rule 36   unop -> MINUSMINUS
rule 37   unop -> '~'
rule 38   unop -> '!'
rule 39   expr -> nonnull_exprlist
rule 40   exprlist ->		/* empty */
rule 41   exprlist -> nonnull_exprlist
rule 42   nonnull_exprlist -> expr_no_commas
rule 43   nonnull_exprlist -> nonnull_exprlist ',' expr_no_commas
rule 44   expr_no_commas -> primary
rule 45   expr_no_commas -> '*' expr_no_commas
rule 46   expr_no_commas -> unop expr_no_commas
rule 47   expr_no_commas -> '(' typename ')' expr_no_commas
rule 48   expr_no_commas -> '(' typename ')' '{' initlist maybecomma '}'
rule 49   expr_no_commas -> SIZEOF expr_no_commas
rule 50   expr_no_commas -> SIZEOF '(' typename ')'
rule 51   expr_no_commas -> ALIGNOF expr_no_commas
rule 52   expr_no_commas -> ALIGNOF '(' typename ')'
rule 53   expr_no_commas -> expr_no_commas '+' expr_no_commas
rule 54   expr_no_commas -> expr_no_commas '-' expr_no_commas
rule 55   expr_no_commas -> expr_no_commas '*' expr_no_commas
rule 56   expr_no_commas -> expr_no_commas '/' expr_no_commas
rule 57   expr_no_commas -> expr_no_commas '%' expr_no_commas
rule 58   expr_no_commas -> expr_no_commas LSHIFT expr_no_commas
rule 59   expr_no_commas -> expr_no_commas RSHIFT expr_no_commas
rule 60   expr_no_commas -> expr_no_commas ARITHCOMPARE expr_no_commas
rule 61   expr_no_commas -> expr_no_commas EQCOMPARE expr_no_commas
rule 62   expr_no_commas -> expr_no_commas '&' expr_no_commas
rule 63   expr_no_commas -> expr_no_commas '|' expr_no_commas
rule 64   expr_no_commas -> expr_no_commas '^' expr_no_commas
rule 65   expr_no_commas -> expr_no_commas ANDAND expr_no_commas
rule 66   expr_no_commas -> expr_no_commas OROR expr_no_commas
rule 67   expr_no_commas -> expr_no_commas '?' xexpr ':' expr_no_commas
rule 68   expr_no_commas -> expr_no_commas '=' expr_no_commas
rule 69   expr_no_commas -> expr_no_commas ASSIGN expr_no_commas
rule 70   primary -> IDENTIFIER
rule 71   primary -> CONSTANT
rule 72   primary -> string
rule 73   primary -> '(' expr ')'
rule 74   primary -> '(' error ')'
rule 75   @9 ->		/* empty */
rule 76   primary -> '(' @9 compstmt ')'
rule 77   primary -> primary '(' exprlist ')'
rule 78   primary -> primary '[' expr ']'
rule 79   primary -> primary '.' identifier
rule 80   primary -> primary POINTSAT identifier
rule 81   primary -> primary PLUSPLUS
rule 82   primary -> primary MINUSMINUS
rule 83   string -> STRING
rule 84   string -> string STRING
rule 85   xdecls ->		/* empty */
rule 86   xdecls -> decls
rule 87   decls -> decl
rule 88   decls -> errstmt
rule 89   decls -> decls decl
rule 90   decls -> decl errstmt
rule 91   setspecs ->		/* empty */
rule 92   decl -> typed_declspecs setspecs initdecls ';'
rule 93   decl -> declmods setspecs notype_initdecls ';'
rule 94   decl -> typed_declspecs ';'
rule 95   decl -> declmods ';'
rule 96   typed_declspecs -> typespec reserved_declspecs
rule 97   typed_declspecs -> declmods typespec reserved_declspecs
rule 98   reserved_declspecs ->		/* empty */
rule 99   reserved_declspecs -> reserved_declspecs typespecqual_reserved
rule 100  reserved_declspecs -> reserved_declspecs SCSPEC
rule 101  declmods -> TYPE_QUAL
rule 102  declmods -> SCSPEC
rule 103  declmods -> declmods TYPE_QUAL
rule 104  declmods -> declmods SCSPEC
rule 105  typed_typespecs -> typespec reserved_typespecquals
rule 106  typed_typespecs -> nonempty_type_quals typespec reserved_typespecquals
rule 107  reserved_typespecquals ->		/* empty */
rule 108  reserved_typespecquals -> reserved_typespecquals typespecqual_reserved
rule 109  typespec -> TYPESPEC
rule 110  typespec -> structsp
rule 111  typespec -> TYPENAME
rule 112  typespec -> TYPEOF '(' expr ')'
rule 113  typespec -> TYPEOF '(' typename ')'
rule 114  typespecqual_reserved -> TYPESPEC
rule 115  typespecqual_reserved -> TYPE_QUAL
rule 116  typespecqual_reserved -> structsp
rule 117  initdecls -> initdcl
rule 118  initdecls -> initdecls ',' initdcl
rule 119  notype_initdecls -> notype_initdcl
rule 120  notype_initdecls -> notype_initdecls ',' initdcl
rule 121  maybeasm ->		/* empty */
rule 122  maybeasm -> ASM '(' string ')'
rule 123  @10 ->		/* empty */
rule 124  initdcl -> declarator maybeasm '=' @10 init
rule 125  initdcl -> declarator maybeasm
rule 126  @11 ->		/* empty */
rule 127  notype_initdcl -> notype_declarator maybeasm '=' @11 init
rule 128  notype_initdcl -> notype_declarator maybeasm
rule 129  init -> expr_no_commas
rule 130  init -> '{' initlist '}'
rule 131  init -> '{' initlist ',' '}'
rule 132  init -> error
rule 133  initlist -> init
rule 134  initlist -> initlist ',' init
rule 135  declarator -> after_type_declarator
rule 136  declarator -> notype_declarator
rule 137  after_type_declarator -> '(' after_type_declarator ')'
rule 138  after_type_declarator -> after_type_declarator '(' parmlist_or_identifiers
rule 139  after_type_declarator -> after_type_declarator '[' expr ']'
rule 140  after_type_declarator -> after_type_declarator '[' ']'
rule 141  after_type_declarator -> '*' type_quals after_type_declarator
rule 142  after_type_declarator -> TYPENAME
rule 143  parm_declarator -> parm_declarator '(' parmlist_or_identifiers
rule 144  parm_declarator -> parm_declarator '[' expr ']'
rule 145  parm_declarator -> parm_declarator '[' ']'
rule 146  parm_declarator -> '*' type_quals parm_declarator
rule 147  parm_declarator -> TYPENAME
rule 148  notype_declarator -> notype_declarator '(' parmlist_or_identifiers
rule 149  notype_declarator -> '(' notype_declarator ')'
rule 150  notype_declarator -> '*' type_quals notype_declarator
rule 151  notype_declarator -> notype_declarator '[' expr ']'
rule 152  notype_declarator -> notype_declarator '[' ']'
rule 153  notype_declarator -> IDENTIFIER
rule 154  @12 ->		/* empty */
rule 155  structsp -> STRUCT identifier '{' @12 component_decl_list '}'
rule 156  structsp -> STRUCT '{' component_decl_list '}'
rule 157  structsp -> STRUCT identifier
rule 158  @13 ->		/* empty */
rule 159  structsp -> UNION identifier '{' @13 component_decl_list '}'
rule 160  structsp -> UNION '{' component_decl_list '}'
rule 161  structsp -> UNION identifier
rule 162  @14 ->		/* empty */
rule 163  structsp -> ENUM identifier '{' @14 enumlist maybecomma '}'
rule 164  @15 ->		/* empty */
rule 165  structsp -> ENUM '{' @15 enumlist maybecomma '}'
rule 166  structsp -> ENUM identifier
rule 167  maybecomma ->		/* empty */
rule 168  maybecomma -> ','
rule 169  component_decl_list ->		/* empty */
rule 170  component_decl_list -> component_decl_list component_decl ';'
rule 171  component_decl_list -> component_decl_list ';'
rule 172  component_decl -> typed_typespecs setspecs components
rule 173  component_decl -> nonempty_type_quals setspecs components
rule 174  component_decl -> error
rule 175  components ->		/* empty */
rule 176  components -> component_declarator
rule 177  components -> components ',' component_declarator
rule 178  component_declarator -> declarator
rule 179  component_declarator -> declarator ':' expr_no_commas
rule 180  component_declarator -> ':' expr_no_commas
rule 181  enumlist -> enumerator
rule 182  enumlist -> enumlist ',' enumerator
rule 183  enumerator -> identifier
rule 184  enumerator -> identifier '=' expr_no_commas
rule 185  typename -> typed_typespecs absdcl
rule 186  typename -> nonempty_type_quals absdcl
rule 187  absdcl ->		/* empty */
rule 188  absdcl -> absdcl1
rule 189  nonempty_type_quals -> TYPE_QUAL
rule 190  nonempty_type_quals -> nonempty_type_quals TYPE_QUAL
rule 191  type_quals ->		/* empty */
rule 192  type_quals -> type_quals TYPE_QUAL
rule 193  absdcl1 -> '(' absdcl1 ')'
rule 194  absdcl1 -> '*' type_quals absdcl1
rule 195  absdcl1 -> '*' type_quals
rule 196  absdcl1 -> absdcl1 '(' parmlist
rule 197  absdcl1 -> absdcl1 '[' expr ']'
rule 198  absdcl1 -> absdcl1 '[' ']'
rule 199  absdcl1 -> '(' parmlist
rule 200  absdcl1 -> '[' expr ']'
rule 201  absdcl1 -> '[' ']'
rule 202  stmts -> stmt
rule 203  stmts -> stmts stmt
rule 204  stmts -> stmts errstmt
rule 205  xstmts ->		/* empty */
rule 206  xstmts -> stmts
rule 207  errstmt -> error ';'
rule 208  pushlevel ->		/* empty */
rule 209  compstmt_or_error -> compstmt
rule 210  compstmt_or_error -> error compstmt
rule 211  compstmt -> '{' '}'
rule 212  compstmt -> '{' pushlevel decls xstmts '}'
rule 213  compstmt -> '{' pushlevel error '}'
rule 214  compstmt -> '{' pushlevel stmts '}'
rule 215  @16 ->		/* empty */
rule 216  simple_if -> IF '(' expr ')' @16 stmt
rule 217  stmt -> compstmt
rule 218  stmt -> expr ';'
rule 219  @17 ->		/* empty */
rule 220  stmt -> simple_if ELSE @17 stmt
rule 221  stmt -> simple_if
rule 222  @18 ->		/* empty */
rule 223  @19 ->		/* empty */
rule 224  stmt -> WHILE @18 '(' expr ')' @19 stmt
rule 225  @20 ->		/* empty */
rule 226  @21 ->		/* empty */
rule 227  stmt -> DO @20 stmt WHILE @21 '(' expr ')' ';'
rule 228  @22 ->		/* empty */
rule 229  @23 ->		/* empty */
rule 230  @24 ->		/* empty */
rule 231  stmt -> FOR '(' xexpr ';' @22 xexpr ';' @23 xexpr ')' @24 stmt
rule 232  @25 ->		/* empty */
rule 233  stmt -> SWITCH '(' expr ')' @25 stmt
rule 234  @26 ->		/* empty */
rule 235  stmt -> CASE expr ':' @26 stmt
rule 236  @27 ->		/* empty */
rule 237  stmt -> DEFAULT ':' @27 stmt
rule 238  stmt -> BREAK ';'
rule 239  stmt -> CONTINUE ';'
rule 240  stmt -> RETURN ';'
rule 241  stmt -> RETURN expr ';'
rule 242  stmt -> ASM maybe_type_qual '(' string ')' ';'
rule 243  stmt -> ASM maybe_type_qual '(' string ':' asm_operands ')' ';'
rule 244  stmt -> ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ')' ';'
rule 245  stmt -> GOTO identifier ';'
rule 246  @28 ->		/* empty */
rule 247  stmt -> identifier ':' @28 stmt
rule 248  stmt -> ';'
rule 249  maybe_type_qual ->		/* empty */
rule 250  maybe_type_qual -> TYPE_QUAL
rule 251  xexpr ->		/* empty */
rule 252  xexpr -> expr
rule 253  asm_operands ->		/* empty */
rule 254  asm_operands -> nonnull_asm_operands
rule 255  nonnull_asm_operands -> asm_operand
rule 256  nonnull_asm_operands -> nonnull_asm_operands ',' asm_operand
rule 257  asm_operand -> STRING '(' expr ')'
rule 258  @29 ->		/* empty */
rule 259  parmlist -> @29 parmlist_1
rule 260  @30 ->		/* empty */
rule 261  parmlist_or_identifiers -> @30 parmlist_or_identifiers_1
rule 262  parmlist_or_identifiers_1 -> parmlist_2 ')'
rule 263  parmlist_or_identifiers_1 -> identifiers ')'
rule 264  parmlist_or_identifiers_1 -> error ')'
rule 265  parmlist_1 -> parmlist_2 ')'
rule 266  parmlist_1 -> error ')'
rule 267  parmlist_2 ->		/* empty */
rule 268  parmlist_2 -> parms
rule 269  parmlist_2 -> parms ',' ELLIPSIS
rule 270  parms -> parm
rule 271  parms -> parms ',' parm
rule 272  parm -> typed_declspecs parm_declarator
rule 273  parm -> typed_declspecs notype_declarator
rule 274  parm -> typed_declspecs absdcl
rule 275  parm -> declmods notype_declarator
rule 276  parm -> declmods absdcl
rule 277  identifiers -> IDENTIFIER
rule 278  identifiers -> identifiers ',' IDENTIFIER

Terminals, with rules where they appear

$ (-1)
'!' (33) 38
'%' (37) 57
'&' (38) 32 62
'(' (40) 9 47 48 50 52 73 74 76 77 112 113 122 137 138 143 148 149
    193 196 199 216 224 227 231 233 242 243 244 257
')' (41) 9 47 48 50 52 73 74 76 77 112 113 122 137 149 193 216 224
    227 231 233 242 243 244 257 262 263 264 265 266
'*' (42) 45 55 141 146 150 194 195
'+' (43) 34 53
',' (44) 43 118 120 131 134 168 177 182 256 269 271 278
'-' (45) 33 54
'.' (46) 79
'/' (47) 56
':' (58) 67 179 180 235 237 243 244 247
';' (59) 9 10 11 12 13 14 15 17 92 93 94 95 170 171 207 218 227 231
    238 239 240 241 242 243 244 245 248
'=' (61) 68 124 127 184
'?' (63) 67
'[' (91) 78 139 140 144 145 151 152 197 198 200 201
']' (93) 78 139 140 144 145 151 152 197 198 200 201
'^' (94) 64
'{' (123) 48 130 131 155 156 159 160 163 165 211 212 213 214
'|' (124) 63
'}' (125) 16 48 130 131 155 156 159 160 163 165 211 212 213 214
'~' (126) 37
error (256) 15 16 21 25 29 74 132 174 207 210 213 264 266
IDENTIFIER (258) 30 70 153 277 278
TYPENAME (259) 31 111 142 147
SCSPEC (260) 100 102 104
TYPESPEC (261) 109 114
TYPE_QUAL (262) 101 103 115 189 190 192 250
CONSTANT (263) 71
STRING (264) 83 84 257
ELLIPSIS (265) 269
SIZEOF (266) 49 50
ENUM (267) 163 165 166
STRUCT (268) 155 156 157
UNION (269) 159 160 161
IF (270) 216
ELSE (271) 220
WHILE (272) 224 227
DO (273) 227
FOR (274) 231
SWITCH (275) 233
CASE (276) 235
DEFAULT (277) 237
BREAK (278) 238
CONTINUE (279) 239
RETURN (280) 240 241
GOTO (281) 245
ASM (282) 9 122 242 243 244
TYPEOF (283) 112 113
ALIGNOF (284) 51 52
ASSIGN (285) 69
OROR (286) 66
ANDAND (287) 65
EQCOMPARE (288) 61
ARITHCOMPARE (289) 60
LSHIFT (290) 58
RSHIFT (291) 59
UNARY (292)
PLUSPLUS (293) 35 81
MINUSMINUS (294) 36 82
HYPERUNARY (295)
POINTSAT (296) 80

Nonterminals, with rules where they appear

program (64)
    on left: 1 2
extdefs (65)
    on left: 4 6, on right: 2 6
@1 (66)
    on left: 3, on right: 4
@2 (67)
    on left: 5, on right: 6
extdef (68)
    on left: 7 8 9, on right: 4 6
datadef (69)
    on left: 10 11 12 13 14 15 16 17, on right: 8
fndef (70)
    on left: 20 21 24 25 28 29, on right: 7
@3 (71)
    on left: 18, on right: 20
@4 (72)
    on left: 19, on right: 20
@5 (73)
    on left: 22, on right: 24
@6 (74)
    on left: 23, on right: 24
@7 (75)
    on left: 26, on right: 28
@8 (76)
    on left: 27, on right: 28
identifier (77)
    on left: 30 31, on right: 79 80 155 157 159 161 163 166 183 184
    245 247
unop (78)
    on left: 32 33 34 35 36 37 38, on right: 46
expr (79)
    on left: 39, on right: 73 78 112 139 144 151 197 200 216 218 224
    227 233 235 241 252 257
exprlist (80)
    on left: 40 41, on right: 77
nonnull_exprlist (81)
    on left: 42 43, on right: 39 41 43
expr_no_commas (82)
    on left: 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61
    62 63 64 65 66 67 68 69, on right: 42 43 45 46 47 49 51 53 54 55
    56 57 58 59 60 61 62 63 64 65 66 67 68 69 129 179 180 184
primary (83)
    on left: 70 71 72 73 74 76 77 78 79 80 81 82, on right: 44 77 78
    79 80 81 82
@9 (84)
    on left: 75, on right: 76
string (85)
    on left: 83 84, on right: 9 72 84 122 242 243 244
xdecls (86)
    on left: 85 86, on right: 20 24 28
decls (87)
    on left: 87 88 89 90, on right: 86 89 212
setspecs (88)
    on left: 91, on right: 10 11 12 20 21 24 25 28 29 92 93 172 173
decl (89)
    on left: 92 93 94 95, on right: 87 89 90
typed_declspecs (90)
    on left: 96 97, on right: 12 14 20 21 92 94 272 273 274
reserved_declspecs (91)
    on left: 98 99 100, on right: 96 97 99 100
declmods (92)
    on left: 101 102 103 104, on right: 11 13 24 25 93 95 97 103 104
    275 276
typed_typespecs (93)
    on left: 105 106, on right: 172 185
reserved_typespecquals (94)
    on left: 107 108, on right: 105 106 108
typespec (95)
    on left: 109 110 111 112 113, on right: 96 97 105 106
typespecqual_reserved (96)
    on left: 114 115 116, on right: 99 108
initdecls (97)
    on left: 117 118, on right: 12 92 118
notype_initdecls (98)
    on left: 119 120, on right: 10 11 93 120
maybeasm (99)
    on left: 121 122, on right: 124 125 127 128
initdcl (100)
    on left: 124 125, on right: 117 118 120
@10 (101)
    on left: 123, on right: 124
notype_initdcl (102)
    on left: 127 128, on right: 119
@11 (103)
    on left: 126, on right: 127
init (104)
    on left: 129 130 131 132, on right: 124 127 133 134
initlist (105)
    on left: 133 134, on right: 48 130 131 134
declarator (106)
    on left: 135 136, on right: 20 21 124 125 178 179
after_type_declarator (107)
    on left: 137 138 139 140 141 142, on right: 135 137 138 139 140
    141
parm_declarator (108)
    on left: 143 144 145 146 147, on right: 143 144 145 146 272
notype_declarator (109)
    on left: 148 149 150 151 152 153, on right: 24 25 28 29 127 128
    136 148 149 150 151 152 273 275
structsp (110)
    on left: 155 156 157 159 160 161 163 165 166, on right: 110 116
@12 (111)
    on left: 154, on right: 155
@13 (112)
    on left: 158, on right: 159
@14 (113)
    on left: 162, on right: 163
@15 (114)
    on left: 164, on right: 165
maybecomma (115)
    on left: 167 168, on right: 48 163 165
component_decl_list (116)
    on left: 169 170 171, on right: 155 156 159 160 170 171
component_decl (117)
    on left: 172 173 174, on right: 170
components (118)
    on left: 175 176 177, on right: 172 173 177
component_declarator (119)
    on left: 178 179 180, on right: 176 177
enumlist (120)
    on left: 181 182, on right: 163 165 182
enumerator (121)
    on left: 183 184, on right: 181 182
typename (122)
    on left: 185 186, on right: 47 48 50 52 113
absdcl (123)
    on left: 187 188, on right: 185 186 274 276
nonempty_type_quals (124)
    on left: 189 190, on right: 106 173 186 190
type_quals (125)
    on left: 191 192, on right: 141 146 150 192 194 195
absdcl1 (126)
    on left: 193 194 195 196 197 198 199 200 201, on right: 188 193
    194 196 197 198
stmts (127)
    on left: 202 203 204, on right: 203 204 206 214
xstmts (128)
    on left: 205 206, on right: 212
errstmt (129)
    on left: 207, on right: 88 90 204
pushlevel (130)
    on left: 208, on right: 212 213 214
compstmt_or_error (131)
    on left: 209 210, on right: 20 24 28
compstmt (132)
    on left: 211 212 213 214, on right: 76 209 210 217
simple_if (133)
    on left: 216, on right: 220 221
@16 (134)
    on left: 215, on right: 216
stmt (135)
    on left: 217 218 220 221 224 227 231 233 235 237 238 239 240 241
    242 243 244 245 247 248, on right: 202 203 216 220 224 227 231
    233 235 237 247
@17 (136)
    on left: 219, on right: 220
@18 (137)
    on left: 222, on right: 224
@19 (138)
    on left: 223, on right: 224
@20 (139)
    on left: 225, on right: 227
@21 (140)
    on left: 226, on right: 227
@22 (141)
    on left: 228, on right: 231
@23 (142)
    on left: 229, on right: 231
@24 (143)
    on left: 230, on right: 231
@25 (144)
    on left: 232, on right: 233
@26 (145)
    on left: 234, on right: 235
@27 (146)
    on left: 236, on right: 237
@28 (147)
    on left: 246, on right: 247
maybe_type_qual (148)
    on left: 249 250, on right: 242 243 244
xexpr (149)
    on left: 251 252, on right: 67 231
asm_operands (150)
    on left: 253 254, on right: 243 244
nonnull_asm_operands (151)
    on left: 255 256, on right: 254 256
asm_operand (152)
    on left: 257, on right: 255 256
parmlist (153)
    on left: 259, on right: 196 199
@29 (154)
    on left: 258, on right: 259
parmlist_or_identifiers (155)
    on left: 261, on right: 138 143 148
@30 (156)
    on left: 260, on right: 261
parmlist_or_identifiers_1 (157)
    on left: 262 263 264, on right: 261
parmlist_1 (158)
    on left: 265 266, on right: 259
parmlist_2 (159)
    on left: 267 268 269, on right: 262 265
parms (160)
    on left: 270 271, on right: 268 269 271
parm (161)
    on left: 272 273 274 275 276, on right: 270 271
identifiers (162)
    on left: 277 278, on right: 263 278


state 0

    $   	reduce using rule 1 (program)
    $default	reduce using rule 3 (@1)

    program	go to state 483
    extdefs	go to state 1
    @1  	go to state 2



state 1

    program  ->  extdefs .   (rule 2)
    extdefs  ->  extdefs . @2 extdef   (rule 6)

    $   	reduce using rule 2 (program)
    $default	reduce using rule 5 (@2)

    @2  	go to state 3



state 2

    extdefs  ->  @1 . extdef   (rule 4)

    error	shift, and go to state 4
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    ASM 	shift, and go to state 12
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 14

    IDENTIFIER	reduce using rule 91 (setspecs)
    '*' 	[reduce using rule 91 (setspecs)]
    '(' 	reduce using rule 91 (setspecs)

    extdef	go to state 15
    datadef	go to state 16
    fndef	go to state 17
    setspecs	go to state 18
    typed_declspecs	go to state 19
    declmods	go to state 20
    typespec	go to state 21
    structsp	go to state 22



state 3

    extdefs  ->  extdefs @2 . extdef   (rule 6)

    error	shift, and go to state 4
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    ASM 	shift, and go to state 12
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 14

    IDENTIFIER	reduce using rule 91 (setspecs)
    '*' 	[reduce using rule 91 (setspecs)]
    '(' 	reduce using rule 91 (setspecs)

    extdef	go to state 23
    datadef	go to state 16
    fndef	go to state 17
    setspecs	go to state 18
    typed_declspecs	go to state 19
    declmods	go to state 20
    typespec	go to state 21
    structsp	go to state 22



state 4

    datadef  ->  error . ';'   (rule 15)
    datadef  ->  error . '}'   (rule 16)

    ';' 	shift, and go to state 24
    '}' 	shift, and go to state 25



state 5

    typespec  ->  TYPENAME .   (rule 111)

    $default	reduce using rule 111 (typespec)



state 6

    declmods  ->  SCSPEC .   (rule 102)

    $default	reduce using rule 102 (declmods)



state 7

    typespec  ->  TYPESPEC .   (rule 109)

    $default	reduce using rule 109 (typespec)



state 8

    declmods  ->  TYPE_QUAL .   (rule 101)

    $default	reduce using rule 101 (declmods)



state 9

    structsp  ->  ENUM . identifier '{' @14 enumlist maybecomma '}'   (rule 163)
    structsp  ->  ENUM . '{' @15 enumlist maybecomma '}'   (rule 165)
    structsp  ->  ENUM . identifier   (rule 166)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27
    '{' 	shift, and go to state 28

    identifier	go to state 29



state 10

    structsp  ->  STRUCT . identifier '{' @12 component_decl_list '}'   (rule 155)
    structsp  ->  STRUCT . '{' component_decl_list '}'   (rule 156)
    structsp  ->  STRUCT . identifier   (rule 157)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27
    '{' 	shift, and go to state 30

    identifier	go to state 31



state 11

    structsp  ->  UNION . identifier '{' @13 component_decl_list '}'   (rule 159)
    structsp  ->  UNION . '{' component_decl_list '}'   (rule 160)
    structsp  ->  UNION . identifier   (rule 161)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27
    '{' 	shift, and go to state 32

    identifier	go to state 33



state 12

    extdef  ->  ASM . '(' string ')' ';'   (rule 9)

    '(' 	shift, and go to state 34



state 13

    typespec  ->  TYPEOF . '(' expr ')'   (rule 112)
    typespec  ->  TYPEOF . '(' typename ')'   (rule 113)

    '(' 	shift, and go to state 35



state 14

    datadef  ->  ';' .   (rule 17)

    $default	reduce using rule 17 (datadef)



state 15

    extdefs  ->  @1 extdef .   (rule 4)

    $default	reduce using rule 4 (extdefs)



state 16

    extdef  ->  datadef .   (rule 8)

    $default	reduce using rule 8 (extdef)



state 17

    extdef  ->  fndef .   (rule 7)

    $default	reduce using rule 7 (extdef)



state 18

    datadef  ->  setspecs . notype_initdecls ';'   (rule 10)
    fndef  ->  setspecs . notype_declarator @7 xdecls @8 compstmt_or_error   (rule 28)
    fndef  ->  setspecs . notype_declarator error   (rule 29)

    IDENTIFIER	shift, and go to state 36
    '*' 	shift, and go to state 37
    '(' 	shift, and go to state 38

    notype_initdecls	go to state 39
    notype_initdcl	go to state 40
    notype_declarator	go to state 41



state 19

    datadef  ->  typed_declspecs . setspecs initdecls ';'   (rule 12)
    datadef  ->  typed_declspecs . ';'   (rule 14)
    fndef  ->  typed_declspecs . setspecs declarator @3 xdecls @4 compstmt_or_error   (rule 20)
    fndef  ->  typed_declspecs . setspecs declarator error   (rule 21)

    ';' 	shift, and go to state 42

    $default	reduce using rule 91 (setspecs)

    setspecs	go to state 43



state 20

    datadef  ->  declmods . setspecs notype_initdecls ';'   (rule 11)
    datadef  ->  declmods . ';'   (rule 13)
    fndef  ->  declmods . setspecs notype_declarator @5 xdecls @6 compstmt_or_error   (rule 24)
    fndef  ->  declmods . setspecs notype_declarator error   (rule 25)
    typed_declspecs  ->  declmods . typespec reserved_declspecs   (rule 97)
    declmods  ->  declmods . TYPE_QUAL   (rule 103)
    declmods  ->  declmods . SCSPEC   (rule 104)

    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 44
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 45
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 46

    $default	reduce using rule 91 (setspecs)

    setspecs	go to state 47
    typespec	go to state 48
    structsp	go to state 22



state 21

    typed_declspecs  ->  typespec . reserved_declspecs   (rule 96)

    $default	reduce using rule 98 (reserved_declspecs)

    reserved_declspecs	go to state 49



state 22

    typespec  ->  structsp .   (rule 110)

    $default	reduce using rule 110 (typespec)



state 23

    extdefs  ->  extdefs @2 extdef .   (rule 6)

    $default	reduce using rule 6 (extdefs)



state 24

    datadef  ->  error ';' .   (rule 15)

    $default	reduce using rule 15 (datadef)



state 25

    datadef  ->  error '}' .   (rule 16)

    $default	reduce using rule 16 (datadef)



state 26

    identifier  ->  IDENTIFIER .   (rule 30)

    $default	reduce using rule 30 (identifier)



state 27

    identifier  ->  TYPENAME .   (rule 31)

    $default	reduce using rule 31 (identifier)



state 28

    structsp  ->  ENUM '{' . @15 enumlist maybecomma '}'   (rule 165)

    $default	reduce using rule 164 (@15)

    @15 	go to state 50



state 29

    structsp  ->  ENUM identifier . '{' @14 enumlist maybecomma '}'   (rule 163)
    structsp  ->  ENUM identifier .   (rule 166)

    '{' 	shift, and go to state 51

    $default	reduce using rule 166 (structsp)



state 30

    structsp  ->  STRUCT '{' . component_decl_list '}'   (rule 156)

    $default	reduce using rule 169 (component_decl_list)

    component_decl_list	go to state 52



state 31

    structsp  ->  STRUCT identifier . '{' @12 component_decl_list '}'   (rule 155)
    structsp  ->  STRUCT identifier .   (rule 157)

    '{' 	shift, and go to state 53

    $default	reduce using rule 157 (structsp)



state 32

    structsp  ->  UNION '{' . component_decl_list '}'   (rule 160)

    $default	reduce using rule 169 (component_decl_list)

    component_decl_list	go to state 54



state 33

    structsp  ->  UNION identifier . '{' @13 component_decl_list '}'   (rule 159)
    structsp  ->  UNION identifier .   (rule 161)

    '{' 	shift, and go to state 55

    $default	reduce using rule 161 (structsp)



state 34

    extdef  ->  ASM '(' . string ')' ';'   (rule 9)

    STRING	shift, and go to state 56

    string	go to state 57



state 35

    typespec  ->  TYPEOF '(' . expr ')'   (rule 112)
    typespec  ->  TYPEOF '(' . typename ')'   (rule 113)

    IDENTIFIER	shift, and go to state 58
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 59
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr	go to state 73
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    typed_typespecs	go to state 78
    typespec	go to state 79
    structsp	go to state 22
    typename	go to state 80
    nonempty_type_quals	go to state 81



state 36

    notype_declarator  ->  IDENTIFIER .   (rule 153)

    $default	reduce using rule 153 (notype_declarator)



state 37

    notype_declarator  ->  '*' . type_quals notype_declarator   (rule 150)

    $default	reduce using rule 191 (type_quals)

    type_quals	go to state 82



state 38

    notype_declarator  ->  '(' . notype_declarator ')'   (rule 149)

    IDENTIFIER	shift, and go to state 36
    '*' 	shift, and go to state 37
    '(' 	shift, and go to state 38

    notype_declarator	go to state 83



state 39

    datadef  ->  setspecs notype_initdecls . ';'   (rule 10)
    notype_initdecls  ->  notype_initdecls . ',' initdcl   (rule 120)

    ';' 	shift, and go to state 84
    ',' 	shift, and go to state 85



state 40

    notype_initdecls  ->  notype_initdcl .   (rule 119)

    $default	reduce using rule 119 (notype_initdecls)



state 41

    fndef  ->  setspecs notype_declarator . @7 xdecls @8 compstmt_or_error   (rule 28)
    fndef  ->  setspecs notype_declarator . error   (rule 29)
    notype_initdcl  ->  notype_declarator . maybeasm '=' @11 init   (rule 127)
    notype_initdcl  ->  notype_declarator . maybeasm   (rule 128)
    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 148)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 151)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 152)

    error	shift, and go to state 86
    ASM 	shift, and go to state 87
    '(' 	shift, and go to state 88
    '[' 	shift, and go to state 89

    error	[reduce using rule 26 (@7)]
    TYPENAME	reduce using rule 26 (@7)
    SCSPEC	reduce using rule 26 (@7)
    TYPESPEC	reduce using rule 26 (@7)
    TYPE_QUAL	reduce using rule 26 (@7)
    ENUM	reduce using rule 26 (@7)
    STRUCT	reduce using rule 26 (@7)
    UNION	reduce using rule 26 (@7)
    TYPEOF	reduce using rule 26 (@7)
    '=' 	reduce using rule 121 (maybeasm)
    ';' 	reduce using rule 121 (maybeasm)
    ',' 	reduce using rule 121 (maybeasm)
    '{' 	reduce using rule 26 (@7)

    @7  	go to state 90
    maybeasm	go to state 91



state 42

    datadef  ->  typed_declspecs ';' .   (rule 14)

    $default	reduce using rule 14 (datadef)



state 43

    datadef  ->  typed_declspecs setspecs . initdecls ';'   (rule 12)
    fndef  ->  typed_declspecs setspecs . declarator @3 xdecls @4 compstmt_or_error   (rule 20)
    fndef  ->  typed_declspecs setspecs . declarator error   (rule 21)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 92
    '*' 	shift, and go to state 93
    '(' 	shift, and go to state 94

    initdecls	go to state 95
    initdcl	go to state 96
    declarator	go to state 97
    after_type_declarator	go to state 98
    notype_declarator	go to state 99



state 44

    declmods  ->  declmods SCSPEC .   (rule 104)

    $default	reduce using rule 104 (declmods)



state 45

    declmods  ->  declmods TYPE_QUAL .   (rule 103)

    $default	reduce using rule 103 (declmods)



state 46

    datadef  ->  declmods ';' .   (rule 13)

    $default	reduce using rule 13 (datadef)



state 47

    datadef  ->  declmods setspecs . notype_initdecls ';'   (rule 11)
    fndef  ->  declmods setspecs . notype_declarator @5 xdecls @6 compstmt_or_error   (rule 24)
    fndef  ->  declmods setspecs . notype_declarator error   (rule 25)

    IDENTIFIER	shift, and go to state 36
    '*' 	shift, and go to state 37
    '(' 	shift, and go to state 38

    notype_initdecls	go to state 100
    notype_initdcl	go to state 40
    notype_declarator	go to state 101



state 48

    typed_declspecs  ->  declmods typespec . reserved_declspecs   (rule 97)

    $default	reduce using rule 98 (reserved_declspecs)

    reserved_declspecs	go to state 102



state 49

    typed_declspecs  ->  typespec reserved_declspecs .   (rule 96)
    reserved_declspecs  ->  reserved_declspecs . typespecqual_reserved   (rule 99)
    reserved_declspecs  ->  reserved_declspecs . SCSPEC   (rule 100)

    SCSPEC	shift, and go to state 103
    TYPESPEC	shift, and go to state 104
    TYPE_QUAL	shift, and go to state 105
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11

    $default	reduce using rule 96 (typed_declspecs)

    typespecqual_reserved	go to state 106
    structsp	go to state 107



state 50

    structsp  ->  ENUM '{' @15 . enumlist maybecomma '}'   (rule 165)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    identifier	go to state 108
    enumlist	go to state 109
    enumerator	go to state 110



state 51

    structsp  ->  ENUM identifier '{' . @14 enumlist maybecomma '}'   (rule 163)

    $default	reduce using rule 162 (@14)

    @14 	go to state 111



state 52

    structsp  ->  STRUCT '{' component_decl_list . '}'   (rule 156)
    component_decl_list  ->  component_decl_list . component_decl ';'   (rule 170)
    component_decl_list  ->  component_decl_list . ';'   (rule 171)

    error	shift, and go to state 112
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 59
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 113
    '}' 	shift, and go to state 114

    typed_typespecs	go to state 115
    typespec	go to state 79
    structsp	go to state 22
    component_decl	go to state 116
    nonempty_type_quals	go to state 117



state 53

    structsp  ->  STRUCT identifier '{' . @12 component_decl_list '}'   (rule 155)

    $default	reduce using rule 154 (@12)

    @12 	go to state 118



state 54

    structsp  ->  UNION '{' component_decl_list . '}'   (rule 160)
    component_decl_list  ->  component_decl_list . component_decl ';'   (rule 170)
    component_decl_list  ->  component_decl_list . ';'   (rule 171)

    error	shift, and go to state 112
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 59
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 113
    '}' 	shift, and go to state 119

    typed_typespecs	go to state 115
    typespec	go to state 79
    structsp	go to state 22
    component_decl	go to state 116
    nonempty_type_quals	go to state 117



state 55

    structsp  ->  UNION identifier '{' . @13 component_decl_list '}'   (rule 159)

    $default	reduce using rule 158 (@13)

    @13 	go to state 120



state 56

    string  ->  STRING .   (rule 83)

    $default	reduce using rule 83 (string)



state 57

    extdef  ->  ASM '(' string . ')' ';'   (rule 9)
    string  ->  string . STRING   (rule 84)

    STRING	shift, and go to state 121
    ')' 	shift, and go to state 122



state 58

    primary  ->  IDENTIFIER .   (rule 70)

    $default	reduce using rule 70 (primary)



state 59

    nonempty_type_quals  ->  TYPE_QUAL .   (rule 189)

    $default	reduce using rule 189 (nonempty_type_quals)



state 60

    primary  ->  CONSTANT .   (rule 71)

    $default	reduce using rule 71 (primary)



state 61

    expr_no_commas  ->  SIZEOF . expr_no_commas   (rule 49)
    expr_no_commas  ->  SIZEOF . '(' typename ')'   (rule 50)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 123
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 124
    primary	go to state 76
    string	go to state 77



state 62

    expr_no_commas  ->  ALIGNOF . expr_no_commas   (rule 51)
    expr_no_commas  ->  ALIGNOF . '(' typename ')'   (rule 52)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 125
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 126
    primary	go to state 76
    string	go to state 77



state 63

    unop  ->  '&' .   (rule 32)

    $default	reduce using rule 32 (unop)



state 64

    unop  ->  '+' .   (rule 34)

    $default	reduce using rule 34 (unop)



state 65

    unop  ->  '-' .   (rule 33)

    $default	reduce using rule 33 (unop)



state 66

    expr_no_commas  ->  '*' . expr_no_commas   (rule 45)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 127
    primary	go to state 76
    string	go to state 77



state 67

    unop  ->  PLUSPLUS .   (rule 35)

    $default	reduce using rule 35 (unop)



state 68

    unop  ->  MINUSMINUS .   (rule 36)

    $default	reduce using rule 36 (unop)



state 69

    expr_no_commas  ->  '(' . typename ')' expr_no_commas   (rule 47)
    expr_no_commas  ->  '(' . typename ')' '{' initlist maybecomma '}'   (rule 48)
    primary  ->  '(' . expr ')'   (rule 73)
    primary  ->  '(' . error ')'   (rule 74)
    primary  ->  '(' . @9 compstmt ')'   (rule 76)

    error	shift, and go to state 128
    IDENTIFIER	shift, and go to state 58
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 59
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    '{' 	[reduce using rule 75 (@9)]

    unop	go to state 72
    expr	go to state 129
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    @9  	go to state 130
    string	go to state 77
    typed_typespecs	go to state 78
    typespec	go to state 79
    structsp	go to state 22
    typename	go to state 131
    nonempty_type_quals	go to state 81



state 70

    unop  ->  '~' .   (rule 37)

    $default	reduce using rule 37 (unop)



state 71

    unop  ->  '!' .   (rule 38)

    $default	reduce using rule 38 (unop)



state 72

    expr_no_commas  ->  unop . expr_no_commas   (rule 46)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 132
    primary	go to state 76
    string	go to state 77



state 73

    typespec  ->  TYPEOF '(' expr . ')'   (rule 112)

    ')' 	shift, and go to state 133



state 74

    expr  ->  nonnull_exprlist .   (rule 39)
    nonnull_exprlist  ->  nonnull_exprlist . ',' expr_no_commas   (rule 43)

    ',' 	shift, and go to state 134

    $default	reduce using rule 39 (expr)



state 75

    nonnull_exprlist  ->  expr_no_commas .   (rule 42)
    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    ASSIGN	shift, and go to state 135
    '=' 	shift, and go to state 136
    '?' 	shift, and go to state 137
    OROR	shift, and go to state 138
    ANDAND	shift, and go to state 139
    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 42 (nonnull_exprlist)



state 76

    expr_no_commas  ->  primary .   (rule 44)
    primary  ->  primary . '(' exprlist ')'   (rule 77)
    primary  ->  primary . '[' expr ']'   (rule 78)
    primary  ->  primary . '.' identifier   (rule 79)
    primary  ->  primary . POINTSAT identifier   (rule 80)
    primary  ->  primary . PLUSPLUS   (rule 81)
    primary  ->  primary . MINUSMINUS   (rule 82)

    PLUSPLUS	shift, and go to state 152
    MINUSMINUS	shift, and go to state 153
    POINTSAT	shift, and go to state 154
    '.' 	shift, and go to state 155
    '(' 	shift, and go to state 156
    '[' 	shift, and go to state 157

    $default	reduce using rule 44 (expr_no_commas)



state 77

    primary  ->  string .   (rule 72)
    string  ->  string . STRING   (rule 84)

    STRING	shift, and go to state 121

    $default	reduce using rule 72 (primary)



state 78

    typename  ->  typed_typespecs . absdcl   (rule 185)

    '*' 	shift, and go to state 158
    '(' 	shift, and go to state 159
    '[' 	shift, and go to state 160

    $default	reduce using rule 187 (absdcl)

    absdcl	go to state 161
    absdcl1	go to state 162



state 79

    typed_typespecs  ->  typespec . reserved_typespecquals   (rule 105)

    $default	reduce using rule 107 (reserved_typespecquals)

    reserved_typespecquals	go to state 163



state 80

    typespec  ->  TYPEOF '(' typename . ')'   (rule 113)

    ')' 	shift, and go to state 164



state 81

    typed_typespecs  ->  nonempty_type_quals . typespec reserved_typespecquals   (rule 106)
    typename  ->  nonempty_type_quals . absdcl   (rule 186)
    nonempty_type_quals  ->  nonempty_type_quals . TYPE_QUAL   (rule 190)

    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 165
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    '*' 	shift, and go to state 158
    '(' 	shift, and go to state 159
    '[' 	shift, and go to state 160

    $default	reduce using rule 187 (absdcl)

    typespec	go to state 166
    structsp	go to state 22
    absdcl	go to state 167
    absdcl1	go to state 162



state 82

    notype_declarator  ->  '*' type_quals . notype_declarator   (rule 150)
    type_quals  ->  type_quals . TYPE_QUAL   (rule 192)

    IDENTIFIER	shift, and go to state 36
    TYPE_QUAL	shift, and go to state 168
    '*' 	shift, and go to state 37
    '(' 	shift, and go to state 38

    notype_declarator	go to state 169



state 83

    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 148)
    notype_declarator  ->  '(' notype_declarator . ')'   (rule 149)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 151)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 152)

    '(' 	shift, and go to state 88
    ')' 	shift, and go to state 170
    '[' 	shift, and go to state 89



state 84

    datadef  ->  setspecs notype_initdecls ';' .   (rule 10)

    $default	reduce using rule 10 (datadef)



state 85

    notype_initdecls  ->  notype_initdecls ',' . initdcl   (rule 120)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 92
    '*' 	shift, and go to state 93
    '(' 	shift, and go to state 94

    initdcl	go to state 171
    declarator	go to state 172
    after_type_declarator	go to state 98
    notype_declarator	go to state 99



state 86

    fndef  ->  setspecs notype_declarator error .   (rule 29)

    $default	reduce using rule 29 (fndef)



state 87

    maybeasm  ->  ASM . '(' string ')'   (rule 122)

    '(' 	shift, and go to state 173



state 88

    notype_declarator  ->  notype_declarator '(' . parmlist_or_identifiers   (rule 148)

    $default	reduce using rule 260 (@30)

    parmlist_or_identifiers	go to state 174
    @30 	go to state 175



state 89

    notype_declarator  ->  notype_declarator '[' . expr ']'   (rule 151)
    notype_declarator  ->  notype_declarator '[' . ']'   (rule 152)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    ']' 	shift, and go to state 176

    unop	go to state 72
    expr	go to state 177
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 90

    fndef  ->  setspecs notype_declarator @7 . xdecls @8 compstmt_or_error   (rule 28)

    error	shift, and go to state 178
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    error	[reduce using rule 85 (xdecls)]
    '{' 	reduce using rule 85 (xdecls)

    xdecls	go to state 179
    decls	go to state 180
    decl	go to state 181
    typed_declspecs	go to state 182
    declmods	go to state 183
    typespec	go to state 21
    structsp	go to state 22
    errstmt	go to state 184



state 91

    notype_initdcl  ->  notype_declarator maybeasm . '=' @11 init   (rule 127)
    notype_initdcl  ->  notype_declarator maybeasm .   (rule 128)

    '=' 	shift, and go to state 185

    $default	reduce using rule 128 (notype_initdcl)



state 92

    after_type_declarator  ->  TYPENAME .   (rule 142)

    $default	reduce using rule 142 (after_type_declarator)



state 93

    after_type_declarator  ->  '*' . type_quals after_type_declarator   (rule 141)
    notype_declarator  ->  '*' . type_quals notype_declarator   (rule 150)

    $default	reduce using rule 191 (type_quals)

    type_quals	go to state 186



state 94

    after_type_declarator  ->  '(' . after_type_declarator ')'   (rule 137)
    notype_declarator  ->  '(' . notype_declarator ')'   (rule 149)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 92
    '*' 	shift, and go to state 93
    '(' 	shift, and go to state 94

    after_type_declarator	go to state 187
    notype_declarator	go to state 83



state 95

    datadef  ->  typed_declspecs setspecs initdecls . ';'   (rule 12)
    initdecls  ->  initdecls . ',' initdcl   (rule 118)

    ';' 	shift, and go to state 188
    ',' 	shift, and go to state 189



state 96

    initdecls  ->  initdcl .   (rule 117)

    $default	reduce using rule 117 (initdecls)



state 97

    fndef  ->  typed_declspecs setspecs declarator . @3 xdecls @4 compstmt_or_error   (rule 20)
    fndef  ->  typed_declspecs setspecs declarator . error   (rule 21)
    initdcl  ->  declarator . maybeasm '=' @10 init   (rule 124)
    initdcl  ->  declarator . maybeasm   (rule 125)

    error	shift, and go to state 190
    ASM 	shift, and go to state 87

    error	[reduce using rule 18 (@3)]
    TYPENAME	reduce using rule 18 (@3)
    SCSPEC	reduce using rule 18 (@3)
    TYPESPEC	reduce using rule 18 (@3)
    TYPE_QUAL	reduce using rule 18 (@3)
    ENUM	reduce using rule 18 (@3)
    STRUCT	reduce using rule 18 (@3)
    UNION	reduce using rule 18 (@3)
    TYPEOF	reduce using rule 18 (@3)
    '=' 	reduce using rule 121 (maybeasm)
    ';' 	reduce using rule 121 (maybeasm)
    ',' 	reduce using rule 121 (maybeasm)
    '{' 	reduce using rule 18 (@3)

    @3  	go to state 191
    maybeasm	go to state 192



state 98

    declarator  ->  after_type_declarator .   (rule 135)
    after_type_declarator  ->  after_type_declarator . '(' parmlist_or_identifiers   (rule 138)
    after_type_declarator  ->  after_type_declarator . '[' expr ']'   (rule 139)
    after_type_declarator  ->  after_type_declarator . '[' ']'   (rule 140)

    '(' 	shift, and go to state 193
    '[' 	shift, and go to state 194

    $default	reduce using rule 135 (declarator)



state 99

    declarator  ->  notype_declarator .   (rule 136)
    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 148)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 151)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 152)

    '(' 	shift, and go to state 88
    '[' 	shift, and go to state 89

    $default	reduce using rule 136 (declarator)



state 100

    datadef  ->  declmods setspecs notype_initdecls . ';'   (rule 11)
    notype_initdecls  ->  notype_initdecls . ',' initdcl   (rule 120)

    ';' 	shift, and go to state 195
    ',' 	shift, and go to state 85



state 101

    fndef  ->  declmods setspecs notype_declarator . @5 xdecls @6 compstmt_or_error   (rule 24)
    fndef  ->  declmods setspecs notype_declarator . error   (rule 25)
    notype_initdcl  ->  notype_declarator . maybeasm '=' @11 init   (rule 127)
    notype_initdcl  ->  notype_declarator . maybeasm   (rule 128)
    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 148)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 151)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 152)

    error	shift, and go to state 196
    ASM 	shift, and go to state 87
    '(' 	shift, and go to state 88
    '[' 	shift, and go to state 89

    error	[reduce using rule 22 (@5)]
    TYPENAME	reduce using rule 22 (@5)
    SCSPEC	reduce using rule 22 (@5)
    TYPESPEC	reduce using rule 22 (@5)
    TYPE_QUAL	reduce using rule 22 (@5)
    ENUM	reduce using rule 22 (@5)
    STRUCT	reduce using rule 22 (@5)
    UNION	reduce using rule 22 (@5)
    TYPEOF	reduce using rule 22 (@5)
    '=' 	reduce using rule 121 (maybeasm)
    ';' 	reduce using rule 121 (maybeasm)
    ',' 	reduce using rule 121 (maybeasm)
    '{' 	reduce using rule 22 (@5)

    @5  	go to state 197
    maybeasm	go to state 91



state 102

    typed_declspecs  ->  declmods typespec reserved_declspecs .   (rule 97)
    reserved_declspecs  ->  reserved_declspecs . typespecqual_reserved   (rule 99)
    reserved_declspecs  ->  reserved_declspecs . SCSPEC   (rule 100)

    SCSPEC	shift, and go to state 103
    TYPESPEC	shift, and go to state 104
    TYPE_QUAL	shift, and go to state 105
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11

    $default	reduce using rule 97 (typed_declspecs)

    typespecqual_reserved	go to state 106
    structsp	go to state 107



state 103

    reserved_declspecs  ->  reserved_declspecs SCSPEC .   (rule 100)

    $default	reduce using rule 100 (reserved_declspecs)



state 104

    typespecqual_reserved  ->  TYPESPEC .   (rule 114)

    $default	reduce using rule 114 (typespecqual_reserved)



state 105

    typespecqual_reserved  ->  TYPE_QUAL .   (rule 115)

    $default	reduce using rule 115 (typespecqual_reserved)



state 106

    reserved_declspecs  ->  reserved_declspecs typespecqual_reserved .   (rule 99)

    $default	reduce using rule 99 (reserved_declspecs)



state 107

    typespecqual_reserved  ->  structsp .   (rule 116)

    $default	reduce using rule 116 (typespecqual_reserved)



state 108

    enumerator  ->  identifier .   (rule 183)
    enumerator  ->  identifier . '=' expr_no_commas   (rule 184)

    '=' 	shift, and go to state 198

    $default	reduce using rule 183 (enumerator)



state 109

    structsp  ->  ENUM '{' @15 enumlist . maybecomma '}'   (rule 165)
    enumlist  ->  enumlist . ',' enumerator   (rule 182)

    ',' 	shift, and go to state 199

    $default	reduce using rule 167 (maybecomma)

    maybecomma	go to state 200



state 110

    enumlist  ->  enumerator .   (rule 181)

    $default	reduce using rule 181 (enumlist)



state 111

    structsp  ->  ENUM identifier '{' @14 . enumlist maybecomma '}'   (rule 163)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    identifier	go to state 108
    enumlist	go to state 201
    enumerator	go to state 110



state 112

    component_decl  ->  error .   (rule 174)

    $default	reduce using rule 174 (component_decl)



state 113

    component_decl_list  ->  component_decl_list ';' .   (rule 171)

    $default	reduce using rule 171 (component_decl_list)



state 114

    structsp  ->  STRUCT '{' component_decl_list '}' .   (rule 156)

    $default	reduce using rule 156 (structsp)



state 115

    component_decl  ->  typed_typespecs . setspecs components   (rule 172)

    $default	reduce using rule 91 (setspecs)

    setspecs	go to state 202



state 116

    component_decl_list  ->  component_decl_list component_decl . ';'   (rule 170)

    ';' 	shift, and go to state 203



state 117

    typed_typespecs  ->  nonempty_type_quals . typespec reserved_typespecquals   (rule 106)
    component_decl  ->  nonempty_type_quals . setspecs components   (rule 173)
    nonempty_type_quals  ->  nonempty_type_quals . TYPE_QUAL   (rule 190)

    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 165
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    TYPENAME	[reduce using rule 91 (setspecs)]
    $default	reduce using rule 91 (setspecs)

    setspecs	go to state 204
    typespec	go to state 166
    structsp	go to state 22



state 118

    structsp  ->  STRUCT identifier '{' @12 . component_decl_list '}'   (rule 155)

    $default	reduce using rule 169 (component_decl_list)

    component_decl_list	go to state 205



state 119

    structsp  ->  UNION '{' component_decl_list '}' .   (rule 160)

    $default	reduce using rule 160 (structsp)



state 120

    structsp  ->  UNION identifier '{' @13 . component_decl_list '}'   (rule 159)

    $default	reduce using rule 169 (component_decl_list)

    component_decl_list	go to state 206



state 121

    string  ->  string STRING .   (rule 84)

    $default	reduce using rule 84 (string)



state 122

    extdef  ->  ASM '(' string ')' . ';'   (rule 9)

    ';' 	shift, and go to state 207



state 123

    expr_no_commas  ->  '(' . typename ')' expr_no_commas   (rule 47)
    expr_no_commas  ->  '(' . typename ')' '{' initlist maybecomma '}'   (rule 48)
    expr_no_commas  ->  SIZEOF '(' . typename ')'   (rule 50)
    primary  ->  '(' . expr ')'   (rule 73)
    primary  ->  '(' . error ')'   (rule 74)
    primary  ->  '(' . @9 compstmt ')'   (rule 76)

    error	shift, and go to state 128
    IDENTIFIER	shift, and go to state 58
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 59
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    '{' 	[reduce using rule 75 (@9)]

    unop	go to state 72
    expr	go to state 129
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    @9  	go to state 130
    string	go to state 77
    typed_typespecs	go to state 78
    typespec	go to state 79
    structsp	go to state 22
    typename	go to state 208
    nonempty_type_quals	go to state 81



state 124

    expr_no_commas  ->  SIZEOF expr_no_commas .   (rule 49)
    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)


    $default	reduce using rule 49 (expr_no_commas)



state 125

    expr_no_commas  ->  '(' . typename ')' expr_no_commas   (rule 47)
    expr_no_commas  ->  '(' . typename ')' '{' initlist maybecomma '}'   (rule 48)
    expr_no_commas  ->  ALIGNOF '(' . typename ')'   (rule 52)
    primary  ->  '(' . expr ')'   (rule 73)
    primary  ->  '(' . error ')'   (rule 74)
    primary  ->  '(' . @9 compstmt ')'   (rule 76)

    error	shift, and go to state 128
    IDENTIFIER	shift, and go to state 58
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 59
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    '{' 	[reduce using rule 75 (@9)]

    unop	go to state 72
    expr	go to state 129
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    @9  	go to state 130
    string	go to state 77
    typed_typespecs	go to state 78
    typespec	go to state 79
    structsp	go to state 22
    typename	go to state 209
    nonempty_type_quals	go to state 81



state 126

    expr_no_commas  ->  ALIGNOF expr_no_commas .   (rule 51)
    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)


    $default	reduce using rule 51 (expr_no_commas)



state 127

    expr_no_commas  ->  '*' expr_no_commas .   (rule 45)
    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)


    $default	reduce using rule 45 (expr_no_commas)



state 128

    primary  ->  '(' error . ')'   (rule 74)

    ')' 	shift, and go to state 210



state 129

    primary  ->  '(' expr . ')'   (rule 73)

    ')' 	shift, and go to state 211



state 130

    primary  ->  '(' @9 . compstmt ')'   (rule 76)

    '{' 	shift, and go to state 212

    compstmt	go to state 213



state 131

    expr_no_commas  ->  '(' typename . ')' expr_no_commas   (rule 47)
    expr_no_commas  ->  '(' typename . ')' '{' initlist maybecomma '}'   (rule 48)

    ')' 	shift, and go to state 214



state 132

    expr_no_commas  ->  unop expr_no_commas .   (rule 46)
    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)


    $default	reduce using rule 46 (expr_no_commas)



state 133

    typespec  ->  TYPEOF '(' expr ')' .   (rule 112)

    $default	reduce using rule 112 (typespec)



state 134

    nonnull_exprlist  ->  nonnull_exprlist ',' . expr_no_commas   (rule 43)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 215
    primary	go to state 76
    string	go to state 77



state 135

    expr_no_commas  ->  expr_no_commas ASSIGN . expr_no_commas   (rule 69)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 216
    primary	go to state 76
    string	go to state 77



state 136

    expr_no_commas  ->  expr_no_commas '=' . expr_no_commas   (rule 68)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 217
    primary	go to state 76
    string	go to state 77



state 137

    expr_no_commas  ->  expr_no_commas '?' . xexpr ':' expr_no_commas   (rule 67)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    $default	reduce using rule 251 (xexpr)

    unop	go to state 72
    expr	go to state 218
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    xexpr	go to state 219



state 138

    expr_no_commas  ->  expr_no_commas OROR . expr_no_commas   (rule 66)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 220
    primary	go to state 76
    string	go to state 77



state 139

    expr_no_commas  ->  expr_no_commas ANDAND . expr_no_commas   (rule 65)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 221
    primary	go to state 76
    string	go to state 77



state 140

    expr_no_commas  ->  expr_no_commas '|' . expr_no_commas   (rule 63)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 222
    primary	go to state 76
    string	go to state 77



state 141

    expr_no_commas  ->  expr_no_commas '^' . expr_no_commas   (rule 64)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 223
    primary	go to state 76
    string	go to state 77



state 142

    expr_no_commas  ->  expr_no_commas '&' . expr_no_commas   (rule 62)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 224
    primary	go to state 76
    string	go to state 77



state 143

    expr_no_commas  ->  expr_no_commas EQCOMPARE . expr_no_commas   (rule 61)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 225
    primary	go to state 76
    string	go to state 77



state 144

    expr_no_commas  ->  expr_no_commas ARITHCOMPARE . expr_no_commas   (rule 60)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 226
    primary	go to state 76
    string	go to state 77



state 145

    expr_no_commas  ->  expr_no_commas LSHIFT . expr_no_commas   (rule 58)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 227
    primary	go to state 76
    string	go to state 77



state 146

    expr_no_commas  ->  expr_no_commas RSHIFT . expr_no_commas   (rule 59)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 228
    primary	go to state 76
    string	go to state 77



state 147

    expr_no_commas  ->  expr_no_commas '+' . expr_no_commas   (rule 53)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 229
    primary	go to state 76
    string	go to state 77



state 148

    expr_no_commas  ->  expr_no_commas '-' . expr_no_commas   (rule 54)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 230
    primary	go to state 76
    string	go to state 77



state 149

    expr_no_commas  ->  expr_no_commas '*' . expr_no_commas   (rule 55)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 231
    primary	go to state 76
    string	go to state 77



state 150

    expr_no_commas  ->  expr_no_commas '/' . expr_no_commas   (rule 56)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 232
    primary	go to state 76
    string	go to state 77



state 151

    expr_no_commas  ->  expr_no_commas '%' . expr_no_commas   (rule 57)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 233
    primary	go to state 76
    string	go to state 77



state 152

    primary  ->  primary PLUSPLUS .   (rule 81)

    $default	reduce using rule 81 (primary)



state 153

    primary  ->  primary MINUSMINUS .   (rule 82)

    $default	reduce using rule 82 (primary)



state 154

    primary  ->  primary POINTSAT . identifier   (rule 80)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    identifier	go to state 234



state 155

    primary  ->  primary '.' . identifier   (rule 79)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    identifier	go to state 235



state 156

    primary  ->  primary '(' . exprlist ')'   (rule 77)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    $default	reduce using rule 40 (exprlist)

    unop	go to state 72
    exprlist	go to state 236
    nonnull_exprlist	go to state 237
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 157

    primary  ->  primary '[' . expr ']'   (rule 78)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr	go to state 238
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 158

    absdcl1  ->  '*' . type_quals absdcl1   (rule 194)
    absdcl1  ->  '*' . type_quals   (rule 195)

    $default	reduce using rule 191 (type_quals)

    type_quals	go to state 239



state 159

    absdcl1  ->  '(' . absdcl1 ')'   (rule 193)
    absdcl1  ->  '(' . parmlist   (rule 199)

    '*' 	shift, and go to state 158
    '(' 	shift, and go to state 159
    '[' 	shift, and go to state 160

    $default	reduce using rule 258 (@29)

    absdcl1	go to state 240
    parmlist	go to state 241
    @29 	go to state 242



state 160

    absdcl1  ->  '[' . expr ']'   (rule 200)
    absdcl1  ->  '[' . ']'   (rule 201)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    ']' 	shift, and go to state 243

    unop	go to state 72
    expr	go to state 244
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 161

    typename  ->  typed_typespecs absdcl .   (rule 185)

    $default	reduce using rule 185 (typename)



state 162

    absdcl  ->  absdcl1 .   (rule 188)
    absdcl1  ->  absdcl1 . '(' parmlist   (rule 196)
    absdcl1  ->  absdcl1 . '[' expr ']'   (rule 197)
    absdcl1  ->  absdcl1 . '[' ']'   (rule 198)

    '(' 	shift, and go to state 245
    '[' 	shift, and go to state 246

    $default	reduce using rule 188 (absdcl)



state 163

    typed_typespecs  ->  typespec reserved_typespecquals .   (rule 105)
    reserved_typespecquals  ->  reserved_typespecquals . typespecqual_reserved   (rule 108)

    TYPESPEC	shift, and go to state 104
    TYPE_QUAL	shift, and go to state 105
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11

    $default	reduce using rule 105 (typed_typespecs)

    typespecqual_reserved	go to state 247
    structsp	go to state 107



state 164

    typespec  ->  TYPEOF '(' typename ')' .   (rule 113)

    $default	reduce using rule 113 (typespec)



state 165

    nonempty_type_quals  ->  nonempty_type_quals TYPE_QUAL .   (rule 190)

    $default	reduce using rule 190 (nonempty_type_quals)



state 166

    typed_typespecs  ->  nonempty_type_quals typespec . reserved_typespecquals   (rule 106)

    $default	reduce using rule 107 (reserved_typespecquals)

    reserved_typespecquals	go to state 248



state 167

    typename  ->  nonempty_type_quals absdcl .   (rule 186)

    $default	reduce using rule 186 (typename)



state 168

    type_quals  ->  type_quals TYPE_QUAL .   (rule 192)

    $default	reduce using rule 192 (type_quals)



state 169

    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 148)
    notype_declarator  ->  '*' type_quals notype_declarator .   (rule 150)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 151)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 152)

    '(' 	shift, and go to state 88
    '[' 	shift, and go to state 89

    '(' 	[reduce using rule 150 (notype_declarator)]
    '[' 	[reduce using rule 150 (notype_declarator)]
    $default	reduce using rule 150 (notype_declarator)



state 170

    notype_declarator  ->  '(' notype_declarator ')' .   (rule 149)

    $default	reduce using rule 149 (notype_declarator)



state 171

    notype_initdecls  ->  notype_initdecls ',' initdcl .   (rule 120)

    $default	reduce using rule 120 (notype_initdecls)



state 172

    initdcl  ->  declarator . maybeasm '=' @10 init   (rule 124)
    initdcl  ->  declarator . maybeasm   (rule 125)

    ASM 	shift, and go to state 87

    $default	reduce using rule 121 (maybeasm)

    maybeasm	go to state 192



state 173

    maybeasm  ->  ASM '(' . string ')'   (rule 122)

    STRING	shift, and go to state 56

    string	go to state 249



state 174

    notype_declarator  ->  notype_declarator '(' parmlist_or_identifiers .   (rule 148)

    $default	reduce using rule 148 (notype_declarator)



state 175

    parmlist_or_identifiers  ->  @30 . parmlist_or_identifiers_1   (rule 261)

    error	shift, and go to state 250
    IDENTIFIER	shift, and go to state 251
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    ')' 	reduce using rule 267 (parmlist_2)

    typed_declspecs	go to state 252
    declmods	go to state 253
    typespec	go to state 21
    structsp	go to state 22
    parmlist_or_identifiers_1	go to state 254
    parmlist_2	go to state 255
    parms	go to state 256
    parm	go to state 257
    identifiers	go to state 258



state 176

    notype_declarator  ->  notype_declarator '[' ']' .   (rule 152)

    $default	reduce using rule 152 (notype_declarator)



state 177

    notype_declarator  ->  notype_declarator '[' expr . ']'   (rule 151)

    ']' 	shift, and go to state 259



state 178

    errstmt  ->  error . ';'   (rule 207)

    ';' 	shift, and go to state 260



state 179

    fndef  ->  setspecs notype_declarator @7 xdecls . @8 compstmt_or_error   (rule 28)

    $default	reduce using rule 27 (@8)

    @8  	go to state 261



state 180

    xdecls  ->  decls .   (rule 86)
    decls  ->  decls . decl   (rule 89)

    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    $default	reduce using rule 86 (xdecls)

    decl	go to state 262
    typed_declspecs	go to state 182
    declmods	go to state 183
    typespec	go to state 21
    structsp	go to state 22



state 181

    decls  ->  decl .   (rule 87)
    decls  ->  decl . errstmt   (rule 90)

    error	shift, and go to state 178

    error	[reduce using rule 87 (decls)]
    IDENTIFIER	reduce using rule 87 (decls)
    TYPENAME	reduce using rule 87 (decls)
    SCSPEC	reduce using rule 87 (decls)
    TYPESPEC	reduce using rule 87 (decls)
    TYPE_QUAL	reduce using rule 87 (decls)
    CONSTANT	reduce using rule 87 (decls)
    STRING	reduce using rule 87 (decls)
    SIZEOF	reduce using rule 87 (decls)
    ENUM	reduce using rule 87 (decls)
    STRUCT	reduce using rule 87 (decls)
    UNION	reduce using rule 87 (decls)
    IF  	reduce using rule 87 (decls)
    WHILE	reduce using rule 87 (decls)
    DO  	reduce using rule 87 (decls)
    FOR 	reduce using rule 87 (decls)
    SWITCH	reduce using rule 87 (decls)
    CASE	reduce using rule 87 (decls)
    DEFAULT	reduce using rule 87 (decls)
    BREAK	reduce using rule 87 (decls)
    CONTINUE	reduce using rule 87 (decls)
    RETURN	reduce using rule 87 (decls)
    GOTO	reduce using rule 87 (decls)
    ASM 	reduce using rule 87 (decls)
    TYPEOF	reduce using rule 87 (decls)
    ALIGNOF	reduce using rule 87 (decls)
    '&' 	reduce using rule 87 (decls)
    '+' 	reduce using rule 87 (decls)
    '-' 	reduce using rule 87 (decls)
    '*' 	reduce using rule 87 (decls)
    PLUSPLUS	reduce using rule 87 (decls)
    MINUSMINUS	reduce using rule 87 (decls)
    '(' 	reduce using rule 87 (decls)
    ';' 	reduce using rule 87 (decls)
    '}' 	reduce using rule 87 (decls)
    '~' 	reduce using rule 87 (decls)
    '!' 	reduce using rule 87 (decls)
    '{' 	reduce using rule 87 (decls)

    errstmt	go to state 263



state 182

    decl  ->  typed_declspecs . setspecs initdecls ';'   (rule 92)
    decl  ->  typed_declspecs . ';'   (rule 94)

    ';' 	shift, and go to state 264

    $default	reduce using rule 91 (setspecs)

    setspecs	go to state 265



state 183

    decl  ->  declmods . setspecs notype_initdecls ';'   (rule 93)
    decl  ->  declmods . ';'   (rule 95)
    typed_declspecs  ->  declmods . typespec reserved_declspecs   (rule 97)
    declmods  ->  declmods . TYPE_QUAL   (rule 103)
    declmods  ->  declmods . SCSPEC   (rule 104)

    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 44
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 45
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 266

    $default	reduce using rule 91 (setspecs)

    setspecs	go to state 267
    typespec	go to state 48
    structsp	go to state 22



state 184

    decls  ->  errstmt .   (rule 88)

    $default	reduce using rule 88 (decls)



state 185

    notype_initdcl  ->  notype_declarator maybeasm '=' . @11 init   (rule 127)

    $default	reduce using rule 126 (@11)

    @11 	go to state 268



state 186

    after_type_declarator  ->  '*' type_quals . after_type_declarator   (rule 141)
    notype_declarator  ->  '*' type_quals . notype_declarator   (rule 150)
    type_quals  ->  type_quals . TYPE_QUAL   (rule 192)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 92
    TYPE_QUAL	shift, and go to state 168
    '*' 	shift, and go to state 93
    '(' 	shift, and go to state 94

    after_type_declarator	go to state 269
    notype_declarator	go to state 169



state 187

    after_type_declarator  ->  '(' after_type_declarator . ')'   (rule 137)
    after_type_declarator  ->  after_type_declarator . '(' parmlist_or_identifiers   (rule 138)
    after_type_declarator  ->  after_type_declarator . '[' expr ']'   (rule 139)
    after_type_declarator  ->  after_type_declarator . '[' ']'   (rule 140)

    '(' 	shift, and go to state 193
    ')' 	shift, and go to state 270
    '[' 	shift, and go to state 194



state 188

    datadef  ->  typed_declspecs setspecs initdecls ';' .   (rule 12)

    $default	reduce using rule 12 (datadef)



state 189

    initdecls  ->  initdecls ',' . initdcl   (rule 118)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 92
    '*' 	shift, and go to state 93
    '(' 	shift, and go to state 94

    initdcl	go to state 271
    declarator	go to state 172
    after_type_declarator	go to state 98
    notype_declarator	go to state 99



state 190

    fndef  ->  typed_declspecs setspecs declarator error .   (rule 21)

    $default	reduce using rule 21 (fndef)



state 191

    fndef  ->  typed_declspecs setspecs declarator @3 . xdecls @4 compstmt_or_error   (rule 20)

    error	shift, and go to state 178
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    error	[reduce using rule 85 (xdecls)]
    '{' 	reduce using rule 85 (xdecls)

    xdecls	go to state 272
    decls	go to state 180
    decl	go to state 181
    typed_declspecs	go to state 182
    declmods	go to state 183
    typespec	go to state 21
    structsp	go to state 22
    errstmt	go to state 184



state 192

    initdcl  ->  declarator maybeasm . '=' @10 init   (rule 124)
    initdcl  ->  declarator maybeasm .   (rule 125)

    '=' 	shift, and go to state 273

    $default	reduce using rule 125 (initdcl)



state 193

    after_type_declarator  ->  after_type_declarator '(' . parmlist_or_identifiers   (rule 138)

    $default	reduce using rule 260 (@30)

    parmlist_or_identifiers	go to state 274
    @30 	go to state 175



state 194

    after_type_declarator  ->  after_type_declarator '[' . expr ']'   (rule 139)
    after_type_declarator  ->  after_type_declarator '[' . ']'   (rule 140)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    ']' 	shift, and go to state 275

    unop	go to state 72
    expr	go to state 276
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 195

    datadef  ->  declmods setspecs notype_initdecls ';' .   (rule 11)

    $default	reduce using rule 11 (datadef)



state 196

    fndef  ->  declmods setspecs notype_declarator error .   (rule 25)

    $default	reduce using rule 25 (fndef)



state 197

    fndef  ->  declmods setspecs notype_declarator @5 . xdecls @6 compstmt_or_error   (rule 24)

    error	shift, and go to state 178
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    error	[reduce using rule 85 (xdecls)]
    '{' 	reduce using rule 85 (xdecls)

    xdecls	go to state 277
    decls	go to state 180
    decl	go to state 181
    typed_declspecs	go to state 182
    declmods	go to state 183
    typespec	go to state 21
    structsp	go to state 22
    errstmt	go to state 184



state 198

    enumerator  ->  identifier '=' . expr_no_commas   (rule 184)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 278
    primary	go to state 76
    string	go to state 77



state 199

    maybecomma  ->  ',' .   (rule 168)
    enumlist  ->  enumlist ',' . enumerator   (rule 182)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    $default	reduce using rule 168 (maybecomma)

    identifier	go to state 108
    enumerator	go to state 279



state 200

    structsp  ->  ENUM '{' @15 enumlist maybecomma . '}'   (rule 165)

    '}' 	shift, and go to state 280



state 201

    structsp  ->  ENUM identifier '{' @14 enumlist . maybecomma '}'   (rule 163)
    enumlist  ->  enumlist . ',' enumerator   (rule 182)

    ',' 	shift, and go to state 199

    $default	reduce using rule 167 (maybecomma)

    maybecomma	go to state 281



state 202

    component_decl  ->  typed_typespecs setspecs . components   (rule 172)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 92
    ':' 	shift, and go to state 282
    '*' 	shift, and go to state 93
    '(' 	shift, and go to state 94

    $default	reduce using rule 175 (components)

    declarator	go to state 283
    after_type_declarator	go to state 98
    notype_declarator	go to state 99
    components	go to state 284
    component_declarator	go to state 285



state 203

    component_decl_list  ->  component_decl_list component_decl ';' .   (rule 170)

    $default	reduce using rule 170 (component_decl_list)



state 204

    component_decl  ->  nonempty_type_quals setspecs . components   (rule 173)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 92
    ':' 	shift, and go to state 282
    '*' 	shift, and go to state 93
    '(' 	shift, and go to state 94

    $default	reduce using rule 175 (components)

    declarator	go to state 283
    after_type_declarator	go to state 98
    notype_declarator	go to state 99
    components	go to state 286
    component_declarator	go to state 285



state 205

    structsp  ->  STRUCT identifier '{' @12 component_decl_list . '}'   (rule 155)
    component_decl_list  ->  component_decl_list . component_decl ';'   (rule 170)
    component_decl_list  ->  component_decl_list . ';'   (rule 171)

    error	shift, and go to state 112
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 59
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 113
    '}' 	shift, and go to state 287

    typed_typespecs	go to state 115
    typespec	go to state 79
    structsp	go to state 22
    component_decl	go to state 116
    nonempty_type_quals	go to state 117



state 206

    structsp  ->  UNION identifier '{' @13 component_decl_list . '}'   (rule 159)
    component_decl_list  ->  component_decl_list . component_decl ';'   (rule 170)
    component_decl_list  ->  component_decl_list . ';'   (rule 171)

    error	shift, and go to state 112
    TYPENAME	shift, and go to state 5
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 59
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    ';' 	shift, and go to state 113
    '}' 	shift, and go to state 288

    typed_typespecs	go to state 115
    typespec	go to state 79
    structsp	go to state 22
    component_decl	go to state 116
    nonempty_type_quals	go to state 117



state 207

    extdef  ->  ASM '(' string ')' ';' .   (rule 9)

    $default	reduce using rule 9 (extdef)



state 208

    expr_no_commas  ->  '(' typename . ')' expr_no_commas   (rule 47)
    expr_no_commas  ->  '(' typename . ')' '{' initlist maybecomma '}'   (rule 48)
    expr_no_commas  ->  SIZEOF '(' typename . ')'   (rule 50)

    ')' 	shift, and go to state 289



state 209

    expr_no_commas  ->  '(' typename . ')' expr_no_commas   (rule 47)
    expr_no_commas  ->  '(' typename . ')' '{' initlist maybecomma '}'   (rule 48)
    expr_no_commas  ->  ALIGNOF '(' typename . ')'   (rule 52)

    ')' 	shift, and go to state 290



state 210

    primary  ->  '(' error ')' .   (rule 74)

    $default	reduce using rule 74 (primary)



state 211

    primary  ->  '(' expr ')' .   (rule 73)

    $default	reduce using rule 73 (primary)



state 212

    compstmt  ->  '{' . '}'   (rule 211)
    compstmt  ->  '{' . pushlevel decls xstmts '}'   (rule 212)
    compstmt  ->  '{' . pushlevel error '}'   (rule 213)
    compstmt  ->  '{' . pushlevel stmts '}'   (rule 214)

    '}' 	shift, and go to state 291

    $default	reduce using rule 208 (pushlevel)

    pushlevel	go to state 292



state 213

    primary  ->  '(' @9 compstmt . ')'   (rule 76)

    ')' 	shift, and go to state 293



state 214

    expr_no_commas  ->  '(' typename ')' . expr_no_commas   (rule 47)
    expr_no_commas  ->  '(' typename ')' . '{' initlist maybecomma '}'   (rule 48)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 294

    unop	go to state 72
    expr_no_commas	go to state 295
    primary	go to state 76
    string	go to state 77



state 215

    nonnull_exprlist  ->  nonnull_exprlist ',' expr_no_commas .   (rule 43)
    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    ASSIGN	shift, and go to state 135
    '=' 	shift, and go to state 136
    '?' 	shift, and go to state 137
    OROR	shift, and go to state 138
    ANDAND	shift, and go to state 139
    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 43 (nonnull_exprlist)



state 216

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)
    expr_no_commas  ->  expr_no_commas ASSIGN expr_no_commas .   (rule 69)

    ASSIGN	shift, and go to state 135
    '=' 	shift, and go to state 136
    '?' 	shift, and go to state 137
    OROR	shift, and go to state 138
    ANDAND	shift, and go to state 139
    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 69 (expr_no_commas)



state 217

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas '=' expr_no_commas .   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    ASSIGN	shift, and go to state 135
    '=' 	shift, and go to state 136
    '?' 	shift, and go to state 137
    OROR	shift, and go to state 138
    ANDAND	shift, and go to state 139
    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 68 (expr_no_commas)



state 218

    xexpr  ->  expr .   (rule 252)

    $default	reduce using rule 252 (xexpr)



state 219

    expr_no_commas  ->  expr_no_commas '?' xexpr . ':' expr_no_commas   (rule 67)

    ':' 	shift, and go to state 296



state 220

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas OROR expr_no_commas .   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    ANDAND	shift, and go to state 139
    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 66 (expr_no_commas)



state 221

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas ANDAND expr_no_commas .   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 65 (expr_no_commas)



state 222

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas '|' expr_no_commas .   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 63 (expr_no_commas)



state 223

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas '^' expr_no_commas .   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 64 (expr_no_commas)



state 224

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas '&' expr_no_commas .   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 62 (expr_no_commas)



state 225

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas EQCOMPARE expr_no_commas .   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 61 (expr_no_commas)



state 226

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas ARITHCOMPARE expr_no_commas .   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 60 (expr_no_commas)



state 227

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas LSHIFT expr_no_commas .   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 58 (expr_no_commas)



state 228

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas RSHIFT expr_no_commas .   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 59 (expr_no_commas)



state 229

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas '+' expr_no_commas .   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 53 (expr_no_commas)



state 230

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas '-' expr_no_commas .   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 54 (expr_no_commas)



state 231

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas '*' expr_no_commas .   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)


    $default	reduce using rule 55 (expr_no_commas)



state 232

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas '/' expr_no_commas .   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)


    $default	reduce using rule 56 (expr_no_commas)



state 233

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas '%' expr_no_commas .   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)


    $default	reduce using rule 57 (expr_no_commas)



state 234

    primary  ->  primary POINTSAT identifier .   (rule 80)

    $default	reduce using rule 80 (primary)



state 235

    primary  ->  primary '.' identifier .   (rule 79)

    $default	reduce using rule 79 (primary)



state 236

    primary  ->  primary '(' exprlist . ')'   (rule 77)

    ')' 	shift, and go to state 297



state 237

    exprlist  ->  nonnull_exprlist .   (rule 41)
    nonnull_exprlist  ->  nonnull_exprlist . ',' expr_no_commas   (rule 43)

    ',' 	shift, and go to state 134

    $default	reduce using rule 41 (exprlist)



state 238

    primary  ->  primary '[' expr . ']'   (rule 78)

    ']' 	shift, and go to state 298



state 239

    type_quals  ->  type_quals . TYPE_QUAL   (rule 192)
    absdcl1  ->  '*' type_quals . absdcl1   (rule 194)
    absdcl1  ->  '*' type_quals .   (rule 195)

    TYPE_QUAL	shift, and go to state 168
    '*' 	shift, and go to state 158
    '(' 	shift, and go to state 159
    '[' 	shift, and go to state 160

    '(' 	[reduce using rule 195 (absdcl1)]
    '[' 	[reduce using rule 195 (absdcl1)]
    $default	reduce using rule 195 (absdcl1)

    absdcl1	go to state 299



state 240

    absdcl1  ->  '(' absdcl1 . ')'   (rule 193)
    absdcl1  ->  absdcl1 . '(' parmlist   (rule 196)
    absdcl1  ->  absdcl1 . '[' expr ']'   (rule 197)
    absdcl1  ->  absdcl1 . '[' ']'   (rule 198)

    '(' 	shift, and go to state 245
    ')' 	shift, and go to state 300
    '[' 	shift, and go to state 246



state 241

    absdcl1  ->  '(' parmlist .   (rule 199)

    $default	reduce using rule 199 (absdcl1)



state 242

    parmlist  ->  @29 . parmlist_1   (rule 259)

    error	shift, and go to state 301
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    ')' 	reduce using rule 267 (parmlist_2)

    typed_declspecs	go to state 252
    declmods	go to state 253
    typespec	go to state 21
    structsp	go to state 22
    parmlist_1	go to state 302
    parmlist_2	go to state 303
    parms	go to state 256
    parm	go to state 257



state 243

    absdcl1  ->  '[' ']' .   (rule 201)

    $default	reduce using rule 201 (absdcl1)



state 244

    absdcl1  ->  '[' expr . ']'   (rule 200)

    ']' 	shift, and go to state 304



state 245

    absdcl1  ->  absdcl1 '(' . parmlist   (rule 196)

    $default	reduce using rule 258 (@29)

    parmlist	go to state 305
    @29 	go to state 242



state 246

    absdcl1  ->  absdcl1 '[' . expr ']'   (rule 197)
    absdcl1  ->  absdcl1 '[' . ']'   (rule 198)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    ']' 	shift, and go to state 306

    unop	go to state 72
    expr	go to state 307
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 247

    reserved_typespecquals  ->  reserved_typespecquals typespecqual_reserved .   (rule 108)

    $default	reduce using rule 108 (reserved_typespecquals)



state 248

    typed_typespecs  ->  nonempty_type_quals typespec reserved_typespecquals .   (rule 106)
    reserved_typespecquals  ->  reserved_typespecquals . typespecqual_reserved   (rule 108)

    TYPESPEC	shift, and go to state 104
    TYPE_QUAL	shift, and go to state 105
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11

    $default	reduce using rule 106 (typed_typespecs)

    typespecqual_reserved	go to state 247
    structsp	go to state 107



state 249

    string  ->  string . STRING   (rule 84)
    maybeasm  ->  ASM '(' string . ')'   (rule 122)

    STRING	shift, and go to state 121
    ')' 	shift, and go to state 308



state 250

    parmlist_or_identifiers_1  ->  error . ')'   (rule 264)

    ')' 	shift, and go to state 309



state 251

    identifiers  ->  IDENTIFIER .   (rule 277)

    $default	reduce using rule 277 (identifiers)



state 252

    parm  ->  typed_declspecs . parm_declarator   (rule 272)
    parm  ->  typed_declspecs . notype_declarator   (rule 273)
    parm  ->  typed_declspecs . absdcl   (rule 274)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 310
    '*' 	shift, and go to state 311
    '(' 	shift, and go to state 312
    '[' 	shift, and go to state 160

    $default	reduce using rule 187 (absdcl)

    parm_declarator	go to state 313
    notype_declarator	go to state 314
    absdcl	go to state 315
    absdcl1	go to state 162



state 253

    typed_declspecs  ->  declmods . typespec reserved_declspecs   (rule 97)
    declmods  ->  declmods . TYPE_QUAL   (rule 103)
    declmods  ->  declmods . SCSPEC   (rule 104)
    parm  ->  declmods . notype_declarator   (rule 275)
    parm  ->  declmods . absdcl   (rule 276)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 44
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 45
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13
    '*' 	shift, and go to state 316
    '(' 	shift, and go to state 312
    '[' 	shift, and go to state 160

    $default	reduce using rule 187 (absdcl)

    typespec	go to state 48
    notype_declarator	go to state 317
    structsp	go to state 22
    absdcl	go to state 318
    absdcl1	go to state 162



state 254

    parmlist_or_identifiers  ->  @30 parmlist_or_identifiers_1 .   (rule 261)

    $default	reduce using rule 261 (parmlist_or_identifiers)



state 255

    parmlist_or_identifiers_1  ->  parmlist_2 . ')'   (rule 262)

    ')' 	shift, and go to state 319



state 256

    parmlist_2  ->  parms .   (rule 268)
    parmlist_2  ->  parms . ',' ELLIPSIS   (rule 269)
    parms  ->  parms . ',' parm   (rule 271)

    ',' 	shift, and go to state 320

    $default	reduce using rule 268 (parmlist_2)



state 257

    parms  ->  parm .   (rule 270)

    $default	reduce using rule 270 (parms)



state 258

    parmlist_or_identifiers_1  ->  identifiers . ')'   (rule 263)
    identifiers  ->  identifiers . ',' IDENTIFIER   (rule 278)

    ')' 	shift, and go to state 321
    ',' 	shift, and go to state 322



state 259

    notype_declarator  ->  notype_declarator '[' expr ']' .   (rule 151)

    $default	reduce using rule 151 (notype_declarator)



state 260

    errstmt  ->  error ';' .   (rule 207)

    $default	reduce using rule 207 (errstmt)



state 261

    fndef  ->  setspecs notype_declarator @7 xdecls @8 . compstmt_or_error   (rule 28)

    error	shift, and go to state 323
    '{' 	shift, and go to state 212

    compstmt_or_error	go to state 324
    compstmt	go to state 325



state 262

    decls  ->  decls decl .   (rule 89)

    $default	reduce using rule 89 (decls)



state 263

    decls  ->  decl errstmt .   (rule 90)

    $default	reduce using rule 90 (decls)



state 264

    decl  ->  typed_declspecs ';' .   (rule 94)

    $default	reduce using rule 94 (decl)



state 265

    decl  ->  typed_declspecs setspecs . initdecls ';'   (rule 92)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 92
    '*' 	shift, and go to state 93
    '(' 	shift, and go to state 94

    initdecls	go to state 326
    initdcl	go to state 96
    declarator	go to state 172
    after_type_declarator	go to state 98
    notype_declarator	go to state 99



state 266

    decl  ->  declmods ';' .   (rule 95)

    $default	reduce using rule 95 (decl)



state 267

    decl  ->  declmods setspecs . notype_initdecls ';'   (rule 93)

    IDENTIFIER	shift, and go to state 36
    '*' 	shift, and go to state 37
    '(' 	shift, and go to state 38

    notype_initdecls	go to state 327
    notype_initdcl	go to state 40
    notype_declarator	go to state 328



state 268

    notype_initdcl  ->  notype_declarator maybeasm '=' @11 . init   (rule 127)

    error	shift, and go to state 329
    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 330

    unop	go to state 72
    expr_no_commas	go to state 331
    primary	go to state 76
    string	go to state 77
    init	go to state 332



state 269

    after_type_declarator  ->  after_type_declarator . '(' parmlist_or_identifiers   (rule 138)
    after_type_declarator  ->  after_type_declarator . '[' expr ']'   (rule 139)
    after_type_declarator  ->  after_type_declarator . '[' ']'   (rule 140)
    after_type_declarator  ->  '*' type_quals after_type_declarator .   (rule 141)

    '(' 	shift, and go to state 193
    '[' 	shift, and go to state 194

    '(' 	[reduce using rule 141 (after_type_declarator)]
    '[' 	[reduce using rule 141 (after_type_declarator)]
    $default	reduce using rule 141 (after_type_declarator)



state 270

    after_type_declarator  ->  '(' after_type_declarator ')' .   (rule 137)

    $default	reduce using rule 137 (after_type_declarator)



state 271

    initdecls  ->  initdecls ',' initdcl .   (rule 118)

    $default	reduce using rule 118 (initdecls)



state 272

    fndef  ->  typed_declspecs setspecs declarator @3 xdecls . @4 compstmt_or_error   (rule 20)

    $default	reduce using rule 19 (@4)

    @4  	go to state 333



state 273

    initdcl  ->  declarator maybeasm '=' . @10 init   (rule 124)

    $default	reduce using rule 123 (@10)

    @10 	go to state 334



state 274

    after_type_declarator  ->  after_type_declarator '(' parmlist_or_identifiers .   (rule 138)

    $default	reduce using rule 138 (after_type_declarator)



state 275

    after_type_declarator  ->  after_type_declarator '[' ']' .   (rule 140)

    $default	reduce using rule 140 (after_type_declarator)



state 276

    after_type_declarator  ->  after_type_declarator '[' expr . ']'   (rule 139)

    ']' 	shift, and go to state 335



state 277

    fndef  ->  declmods setspecs notype_declarator @5 xdecls . @6 compstmt_or_error   (rule 24)

    $default	reduce using rule 23 (@6)

    @6  	go to state 336



state 278

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)
    enumerator  ->  identifier '=' expr_no_commas .   (rule 184)

    ASSIGN	shift, and go to state 135
    '=' 	shift, and go to state 136
    '?' 	shift, and go to state 137
    OROR	shift, and go to state 138
    ANDAND	shift, and go to state 139
    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 184 (enumerator)



state 279

    enumlist  ->  enumlist ',' enumerator .   (rule 182)

    $default	reduce using rule 182 (enumlist)



state 280

    structsp  ->  ENUM '{' @15 enumlist maybecomma '}' .   (rule 165)

    $default	reduce using rule 165 (structsp)



state 281

    structsp  ->  ENUM identifier '{' @14 enumlist maybecomma . '}'   (rule 163)

    '}' 	shift, and go to state 337



state 282

    component_declarator  ->  ':' . expr_no_commas   (rule 180)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 338
    primary	go to state 76
    string	go to state 77



state 283

    component_declarator  ->  declarator .   (rule 178)
    component_declarator  ->  declarator . ':' expr_no_commas   (rule 179)

    ':' 	shift, and go to state 339

    $default	reduce using rule 178 (component_declarator)



state 284

    component_decl  ->  typed_typespecs setspecs components .   (rule 172)
    components  ->  components . ',' component_declarator   (rule 177)

    ',' 	shift, and go to state 340

    $default	reduce using rule 172 (component_decl)



state 285

    components  ->  component_declarator .   (rule 176)

    $default	reduce using rule 176 (components)



state 286

    component_decl  ->  nonempty_type_quals setspecs components .   (rule 173)
    components  ->  components . ',' component_declarator   (rule 177)

    ',' 	shift, and go to state 340

    $default	reduce using rule 173 (component_decl)



state 287

    structsp  ->  STRUCT identifier '{' @12 component_decl_list '}' .   (rule 155)

    $default	reduce using rule 155 (structsp)



state 288

    structsp  ->  UNION identifier '{' @13 component_decl_list '}' .   (rule 159)

    $default	reduce using rule 159 (structsp)



state 289

    expr_no_commas  ->  '(' typename ')' . expr_no_commas   (rule 47)
    expr_no_commas  ->  '(' typename ')' . '{' initlist maybecomma '}'   (rule 48)
    expr_no_commas  ->  SIZEOF '(' typename ')' .   (rule 50)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 294

    $default	reduce using rule 50 (expr_no_commas)

    unop	go to state 72
    expr_no_commas	go to state 295
    primary	go to state 76
    string	go to state 77



state 290

    expr_no_commas  ->  '(' typename ')' . expr_no_commas   (rule 47)
    expr_no_commas  ->  '(' typename ')' . '{' initlist maybecomma '}'   (rule 48)
    expr_no_commas  ->  ALIGNOF '(' typename ')' .   (rule 52)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 294

    $default	reduce using rule 52 (expr_no_commas)

    unop	go to state 72
    expr_no_commas	go to state 295
    primary	go to state 76
    string	go to state 77



state 291

    compstmt  ->  '{' '}' .   (rule 211)

    $default	reduce using rule 211 (compstmt)



state 292

    compstmt  ->  '{' pushlevel . decls xstmts '}'   (rule 212)
    compstmt  ->  '{' pushlevel . error '}'   (rule 213)
    compstmt  ->  '{' pushlevel . stmts '}'   (rule 214)

    error	shift, and go to state 341
    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 343
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    decls	go to state 359
    decl	go to state 181
    typed_declspecs	go to state 182
    declmods	go to state 183
    typespec	go to state 21
    structsp	go to state 22
    stmts	go to state 360
    errstmt	go to state 184
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 363



state 293

    primary  ->  '(' @9 compstmt ')' .   (rule 76)

    $default	reduce using rule 76 (primary)



state 294

    expr_no_commas  ->  '(' typename ')' '{' . initlist maybecomma '}'   (rule 48)

    error	shift, and go to state 329
    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 330

    unop	go to state 72
    expr_no_commas	go to state 331
    primary	go to state 76
    string	go to state 77
    init	go to state 364
    initlist	go to state 365



state 295

    expr_no_commas  ->  '(' typename ')' expr_no_commas .   (rule 47)
    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)


    $default	reduce using rule 47 (expr_no_commas)



state 296

    expr_no_commas  ->  expr_no_commas '?' xexpr ':' . expr_no_commas   (rule 67)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 366
    primary	go to state 76
    string	go to state 77



state 297

    primary  ->  primary '(' exprlist ')' .   (rule 77)

    $default	reduce using rule 77 (primary)



state 298

    primary  ->  primary '[' expr ']' .   (rule 78)

    $default	reduce using rule 78 (primary)



state 299

    absdcl1  ->  '*' type_quals absdcl1 .   (rule 194)
    absdcl1  ->  absdcl1 . '(' parmlist   (rule 196)
    absdcl1  ->  absdcl1 . '[' expr ']'   (rule 197)
    absdcl1  ->  absdcl1 . '[' ']'   (rule 198)

    '(' 	shift, and go to state 245
    '[' 	shift, and go to state 246

    '(' 	[reduce using rule 194 (absdcl1)]
    '[' 	[reduce using rule 194 (absdcl1)]
    $default	reduce using rule 194 (absdcl1)



state 300

    absdcl1  ->  '(' absdcl1 ')' .   (rule 193)

    $default	reduce using rule 193 (absdcl1)



state 301

    parmlist_1  ->  error . ')'   (rule 266)

    ')' 	shift, and go to state 367



state 302

    parmlist  ->  @29 parmlist_1 .   (rule 259)

    $default	reduce using rule 259 (parmlist)



state 303

    parmlist_1  ->  parmlist_2 . ')'   (rule 265)

    ')' 	shift, and go to state 368



state 304

    absdcl1  ->  '[' expr ']' .   (rule 200)

    $default	reduce using rule 200 (absdcl1)



state 305

    absdcl1  ->  absdcl1 '(' parmlist .   (rule 196)

    $default	reduce using rule 196 (absdcl1)



state 306

    absdcl1  ->  absdcl1 '[' ']' .   (rule 198)

    $default	reduce using rule 198 (absdcl1)



state 307

    absdcl1  ->  absdcl1 '[' expr . ']'   (rule 197)

    ']' 	shift, and go to state 369



state 308

    maybeasm  ->  ASM '(' string ')' .   (rule 122)

    $default	reduce using rule 122 (maybeasm)



state 309

    parmlist_or_identifiers_1  ->  error ')' .   (rule 264)

    $default	reduce using rule 264 (parmlist_or_identifiers_1)



state 310

    parm_declarator  ->  TYPENAME .   (rule 147)

    $default	reduce using rule 147 (parm_declarator)



state 311

    parm_declarator  ->  '*' . type_quals parm_declarator   (rule 146)
    notype_declarator  ->  '*' . type_quals notype_declarator   (rule 150)
    absdcl1  ->  '*' . type_quals absdcl1   (rule 194)
    absdcl1  ->  '*' . type_quals   (rule 195)

    $default	reduce using rule 191 (type_quals)

    type_quals	go to state 370



state 312

    notype_declarator  ->  '(' . notype_declarator ')'   (rule 149)
    absdcl1  ->  '(' . absdcl1 ')'   (rule 193)
    absdcl1  ->  '(' . parmlist   (rule 199)

    IDENTIFIER	shift, and go to state 36
    '*' 	shift, and go to state 316
    '(' 	shift, and go to state 312
    '[' 	shift, and go to state 160

    $default	reduce using rule 258 (@29)

    notype_declarator	go to state 83
    absdcl1	go to state 240
    parmlist	go to state 241
    @29 	go to state 242



state 313

    parm_declarator  ->  parm_declarator . '(' parmlist_or_identifiers   (rule 143)
    parm_declarator  ->  parm_declarator . '[' expr ']'   (rule 144)
    parm_declarator  ->  parm_declarator . '[' ']'   (rule 145)
    parm  ->  typed_declspecs parm_declarator .   (rule 272)

    '(' 	shift, and go to state 371
    '[' 	shift, and go to state 372

    $default	reduce using rule 272 (parm)



state 314

    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 148)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 151)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 152)
    parm  ->  typed_declspecs notype_declarator .   (rule 273)

    '(' 	shift, and go to state 88
    '[' 	shift, and go to state 89

    $default	reduce using rule 273 (parm)



state 315

    parm  ->  typed_declspecs absdcl .   (rule 274)

    $default	reduce using rule 274 (parm)



state 316

    notype_declarator  ->  '*' . type_quals notype_declarator   (rule 150)
    absdcl1  ->  '*' . type_quals absdcl1   (rule 194)
    absdcl1  ->  '*' . type_quals   (rule 195)

    $default	reduce using rule 191 (type_quals)

    type_quals	go to state 373



state 317

    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 148)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 151)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 152)
    parm  ->  declmods notype_declarator .   (rule 275)

    '(' 	shift, and go to state 88
    '[' 	shift, and go to state 89

    $default	reduce using rule 275 (parm)



state 318

    parm  ->  declmods absdcl .   (rule 276)

    $default	reduce using rule 276 (parm)



state 319

    parmlist_or_identifiers_1  ->  parmlist_2 ')' .   (rule 262)

    $default	reduce using rule 262 (parmlist_or_identifiers_1)



state 320

    parmlist_2  ->  parms ',' . ELLIPSIS   (rule 269)
    parms  ->  parms ',' . parm   (rule 271)

    TYPENAME	shift, and go to state 5
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    ELLIPSIS	shift, and go to state 374
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    TYPEOF	shift, and go to state 13

    typed_declspecs	go to state 252
    declmods	go to state 253
    typespec	go to state 21
    structsp	go to state 22
    parm	go to state 375



state 321

    parmlist_or_identifiers_1  ->  identifiers ')' .   (rule 263)

    $default	reduce using rule 263 (parmlist_or_identifiers_1)



state 322

    identifiers  ->  identifiers ',' . IDENTIFIER   (rule 278)

    IDENTIFIER	shift, and go to state 376



state 323

    compstmt_or_error  ->  error . compstmt   (rule 210)

    '{' 	shift, and go to state 212

    compstmt	go to state 377



state 324

    fndef  ->  setspecs notype_declarator @7 xdecls @8 compstmt_or_error .   (rule 28)

    $default	reduce using rule 28 (fndef)



state 325

    compstmt_or_error  ->  compstmt .   (rule 209)

    $default	reduce using rule 209 (compstmt_or_error)



state 326

    decl  ->  typed_declspecs setspecs initdecls . ';'   (rule 92)
    initdecls  ->  initdecls . ',' initdcl   (rule 118)

    ';' 	shift, and go to state 378
    ',' 	shift, and go to state 189



state 327

    decl  ->  declmods setspecs notype_initdecls . ';'   (rule 93)
    notype_initdecls  ->  notype_initdecls . ',' initdcl   (rule 120)

    ';' 	shift, and go to state 379
    ',' 	shift, and go to state 85



state 328

    notype_initdcl  ->  notype_declarator . maybeasm '=' @11 init   (rule 127)
    notype_initdcl  ->  notype_declarator . maybeasm   (rule 128)
    notype_declarator  ->  notype_declarator . '(' parmlist_or_identifiers   (rule 148)
    notype_declarator  ->  notype_declarator . '[' expr ']'   (rule 151)
    notype_declarator  ->  notype_declarator . '[' ']'   (rule 152)

    ASM 	shift, and go to state 87
    '(' 	shift, and go to state 88
    '[' 	shift, and go to state 89

    $default	reduce using rule 121 (maybeasm)

    maybeasm	go to state 91



state 329

    init  ->  error .   (rule 132)

    $default	reduce using rule 132 (init)



state 330

    init  ->  '{' . initlist '}'   (rule 130)
    init  ->  '{' . initlist ',' '}'   (rule 131)

    error	shift, and go to state 329
    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 330

    unop	go to state 72
    expr_no_commas	go to state 331
    primary	go to state 76
    string	go to state 77
    init	go to state 364
    initlist	go to state 380



state 331

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)
    init  ->  expr_no_commas .   (rule 129)

    ASSIGN	shift, and go to state 135
    '=' 	shift, and go to state 136
    '?' 	shift, and go to state 137
    OROR	shift, and go to state 138
    ANDAND	shift, and go to state 139
    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 129 (init)



state 332

    notype_initdcl  ->  notype_declarator maybeasm '=' @11 init .   (rule 127)

    $default	reduce using rule 127 (notype_initdcl)



state 333

    fndef  ->  typed_declspecs setspecs declarator @3 xdecls @4 . compstmt_or_error   (rule 20)

    error	shift, and go to state 323
    '{' 	shift, and go to state 212

    compstmt_or_error	go to state 381
    compstmt	go to state 325



state 334

    initdcl  ->  declarator maybeasm '=' @10 . init   (rule 124)

    error	shift, and go to state 329
    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 330

    unop	go to state 72
    expr_no_commas	go to state 331
    primary	go to state 76
    string	go to state 77
    init	go to state 382



state 335

    after_type_declarator  ->  after_type_declarator '[' expr ']' .   (rule 139)

    $default	reduce using rule 139 (after_type_declarator)



state 336

    fndef  ->  declmods setspecs notype_declarator @5 xdecls @6 . compstmt_or_error   (rule 24)

    error	shift, and go to state 323
    '{' 	shift, and go to state 212

    compstmt_or_error	go to state 383
    compstmt	go to state 325



state 337

    structsp  ->  ENUM identifier '{' @14 enumlist maybecomma '}' .   (rule 163)

    $default	reduce using rule 163 (structsp)



state 338

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)
    component_declarator  ->  ':' expr_no_commas .   (rule 180)

    ASSIGN	shift, and go to state 135
    '=' 	shift, and go to state 136
    '?' 	shift, and go to state 137
    OROR	shift, and go to state 138
    ANDAND	shift, and go to state 139
    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 180 (component_declarator)



state 339

    component_declarator  ->  declarator ':' . expr_no_commas   (rule 179)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr_no_commas	go to state 384
    primary	go to state 76
    string	go to state 77



state 340

    components  ->  components ',' . component_declarator   (rule 177)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 92
    ':' 	shift, and go to state 282
    '*' 	shift, and go to state 93
    '(' 	shift, and go to state 94

    declarator	go to state 283
    after_type_declarator	go to state 98
    notype_declarator	go to state 99
    component_declarator	go to state 385



state 341

    errstmt  ->  error . ';'   (rule 207)
    compstmt  ->  '{' pushlevel error . '}'   (rule 213)

    ';' 	shift, and go to state 260
    '}' 	shift, and go to state 386



state 342

    identifier  ->  IDENTIFIER .   (rule 30)
    primary  ->  IDENTIFIER .   (rule 70)

    ':' 	reduce using rule 30 (identifier)
    $default	reduce using rule 70 (primary)



state 343

    identifier  ->  TYPENAME .   (rule 31)
    typespec  ->  TYPENAME .   (rule 111)

    ':' 	reduce using rule 31 (identifier)
    $default	reduce using rule 111 (typespec)



state 344

    simple_if  ->  IF . '(' expr ')' @16 stmt   (rule 216)

    '(' 	shift, and go to state 387



state 345

    stmt  ->  WHILE . @18 '(' expr ')' @19 stmt   (rule 224)

    $default	reduce using rule 222 (@18)

    @18 	go to state 388



state 346

    stmt  ->  DO . @20 stmt WHILE @21 '(' expr ')' ';'   (rule 227)

    $default	reduce using rule 225 (@20)

    @20 	go to state 389



state 347

    stmt  ->  FOR . '(' xexpr ';' @22 xexpr ';' @23 xexpr ')' @24 stmt   (rule 231)

    '(' 	shift, and go to state 390



state 348

    stmt  ->  SWITCH . '(' expr ')' @25 stmt   (rule 233)

    '(' 	shift, and go to state 391



state 349

    stmt  ->  CASE . expr ':' @26 stmt   (rule 235)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr	go to state 392
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 350

    stmt  ->  DEFAULT . ':' @27 stmt   (rule 237)

    ':' 	shift, and go to state 393



state 351

    stmt  ->  BREAK . ';'   (rule 238)

    ';' 	shift, and go to state 394



state 352

    stmt  ->  CONTINUE . ';'   (rule 239)

    ';' 	shift, and go to state 395



state 353

    stmt  ->  RETURN . ';'   (rule 240)
    stmt  ->  RETURN . expr ';'   (rule 241)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 396
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr	go to state 397
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 354

    stmt  ->  GOTO . identifier ';'   (rule 245)

    IDENTIFIER	shift, and go to state 26
    TYPENAME	shift, and go to state 27

    identifier	go to state 398



state 355

    stmt  ->  ASM . maybe_type_qual '(' string ')' ';'   (rule 242)
    stmt  ->  ASM . maybe_type_qual '(' string ':' asm_operands ')' ';'   (rule 243)
    stmt  ->  ASM . maybe_type_qual '(' string ':' asm_operands ':' asm_operands ')' ';'   (rule 244)

    TYPE_QUAL	shift, and go to state 399

    $default	reduce using rule 249 (maybe_type_qual)

    maybe_type_qual	go to state 400



state 356

    stmt  ->  ';' .   (rule 248)

    $default	reduce using rule 248 (stmt)



state 357

    stmt  ->  identifier . ':' @28 stmt   (rule 247)

    ':' 	shift, and go to state 401



state 358

    stmt  ->  expr . ';'   (rule 218)

    ';' 	shift, and go to state 402



state 359

    decls  ->  decls . decl   (rule 89)
    compstmt  ->  '{' pushlevel decls . xstmts '}'   (rule 212)

    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 343
    SCSPEC	shift, and go to state 6
    TYPESPEC	shift, and go to state 7
    TYPE_QUAL	shift, and go to state 8
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ENUM	shift, and go to state 9
    STRUCT	shift, and go to state 10
    UNION	shift, and go to state 11
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    TYPEOF	shift, and go to state 13
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    $default	reduce using rule 205 (xstmts)

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    decl	go to state 262
    typed_declspecs	go to state 182
    declmods	go to state 183
    typespec	go to state 21
    structsp	go to state 22
    stmts	go to state 403
    xstmts	go to state 404
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 363



state 360

    stmts  ->  stmts . stmt   (rule 203)
    stmts  ->  stmts . errstmt   (rule 204)
    compstmt  ->  '{' pushlevel stmts . '}'   (rule 214)

    error	shift, and go to state 178
    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '}' 	shift, and go to state 405
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    errstmt	go to state 406
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 407



state 361

    stmt  ->  compstmt .   (rule 217)

    $default	reduce using rule 217 (stmt)



state 362

    stmt  ->  simple_if . ELSE @17 stmt   (rule 220)
    stmt  ->  simple_if .   (rule 221)

    ELSE	shift, and go to state 408

    ELSE	[reduce using rule 221 (stmt)]
    $default	reduce using rule 221 (stmt)



state 363

    stmts  ->  stmt .   (rule 202)

    $default	reduce using rule 202 (stmts)



state 364

    initlist  ->  init .   (rule 133)

    $default	reduce using rule 133 (initlist)



state 365

    expr_no_commas  ->  '(' typename ')' '{' initlist . maybecomma '}'   (rule 48)
    initlist  ->  initlist . ',' init   (rule 134)

    ',' 	shift, and go to state 409

    $default	reduce using rule 167 (maybecomma)

    maybecomma	go to state 410



state 366

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas '?' xexpr ':' expr_no_commas .   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)

    '?' 	shift, and go to state 137
    OROR	shift, and go to state 138
    ANDAND	shift, and go to state 139
    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 67 (expr_no_commas)



state 367

    parmlist_1  ->  error ')' .   (rule 266)

    $default	reduce using rule 266 (parmlist_1)



state 368

    parmlist_1  ->  parmlist_2 ')' .   (rule 265)

    $default	reduce using rule 265 (parmlist_1)



state 369

    absdcl1  ->  absdcl1 '[' expr ']' .   (rule 197)

    $default	reduce using rule 197 (absdcl1)



state 370

    parm_declarator  ->  '*' type_quals . parm_declarator   (rule 146)
    notype_declarator  ->  '*' type_quals . notype_declarator   (rule 150)
    type_quals  ->  type_quals . TYPE_QUAL   (rule 192)
    absdcl1  ->  '*' type_quals . absdcl1   (rule 194)
    absdcl1  ->  '*' type_quals .   (rule 195)

    IDENTIFIER	shift, and go to state 36
    TYPENAME	shift, and go to state 310
    TYPE_QUAL	shift, and go to state 168
    '*' 	shift, and go to state 311
    '(' 	shift, and go to state 312
    '[' 	shift, and go to state 160

    '(' 	[reduce using rule 195 (absdcl1)]
    '[' 	[reduce using rule 195 (absdcl1)]
    $default	reduce using rule 195 (absdcl1)

    parm_declarator	go to state 411
    notype_declarator	go to state 169
    absdcl1	go to state 299



state 371

    parm_declarator  ->  parm_declarator '(' . parmlist_or_identifiers   (rule 143)

    $default	reduce using rule 260 (@30)

    parmlist_or_identifiers	go to state 412
    @30 	go to state 175



state 372

    parm_declarator  ->  parm_declarator '[' . expr ']'   (rule 144)
    parm_declarator  ->  parm_declarator '[' . ']'   (rule 145)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    ']' 	shift, and go to state 413

    unop	go to state 72
    expr	go to state 414
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 373

    notype_declarator  ->  '*' type_quals . notype_declarator   (rule 150)
    type_quals  ->  type_quals . TYPE_QUAL   (rule 192)
    absdcl1  ->  '*' type_quals . absdcl1   (rule 194)
    absdcl1  ->  '*' type_quals .   (rule 195)

    IDENTIFIER	shift, and go to state 36
    TYPE_QUAL	shift, and go to state 168
    '*' 	shift, and go to state 316
    '(' 	shift, and go to state 312
    '[' 	shift, and go to state 160

    '(' 	[reduce using rule 195 (absdcl1)]
    '[' 	[reduce using rule 195 (absdcl1)]
    $default	reduce using rule 195 (absdcl1)

    notype_declarator	go to state 169
    absdcl1	go to state 299



state 374

    parmlist_2  ->  parms ',' ELLIPSIS .   (rule 269)

    $default	reduce using rule 269 (parmlist_2)



state 375

    parms  ->  parms ',' parm .   (rule 271)

    $default	reduce using rule 271 (parms)



state 376

    identifiers  ->  identifiers ',' IDENTIFIER .   (rule 278)

    $default	reduce using rule 278 (identifiers)



state 377

    compstmt_or_error  ->  error compstmt .   (rule 210)

    $default	reduce using rule 210 (compstmt_or_error)



state 378

    decl  ->  typed_declspecs setspecs initdecls ';' .   (rule 92)

    $default	reduce using rule 92 (decl)



state 379

    decl  ->  declmods setspecs notype_initdecls ';' .   (rule 93)

    $default	reduce using rule 93 (decl)



state 380

    init  ->  '{' initlist . '}'   (rule 130)
    init  ->  '{' initlist . ',' '}'   (rule 131)
    initlist  ->  initlist . ',' init   (rule 134)

    '}' 	shift, and go to state 415
    ',' 	shift, and go to state 416



state 381

    fndef  ->  typed_declspecs setspecs declarator @3 xdecls @4 compstmt_or_error .   (rule 20)

    $default	reduce using rule 20 (fndef)



state 382

    initdcl  ->  declarator maybeasm '=' @10 init .   (rule 124)

    $default	reduce using rule 124 (initdcl)



state 383

    fndef  ->  declmods setspecs notype_declarator @5 xdecls @6 compstmt_or_error .   (rule 24)

    $default	reduce using rule 24 (fndef)



state 384

    expr_no_commas  ->  expr_no_commas . '+' expr_no_commas   (rule 53)
    expr_no_commas  ->  expr_no_commas . '-' expr_no_commas   (rule 54)
    expr_no_commas  ->  expr_no_commas . '*' expr_no_commas   (rule 55)
    expr_no_commas  ->  expr_no_commas . '/' expr_no_commas   (rule 56)
    expr_no_commas  ->  expr_no_commas . '%' expr_no_commas   (rule 57)
    expr_no_commas  ->  expr_no_commas . LSHIFT expr_no_commas   (rule 58)
    expr_no_commas  ->  expr_no_commas . RSHIFT expr_no_commas   (rule 59)
    expr_no_commas  ->  expr_no_commas . ARITHCOMPARE expr_no_commas   (rule 60)
    expr_no_commas  ->  expr_no_commas . EQCOMPARE expr_no_commas   (rule 61)
    expr_no_commas  ->  expr_no_commas . '&' expr_no_commas   (rule 62)
    expr_no_commas  ->  expr_no_commas . '|' expr_no_commas   (rule 63)
    expr_no_commas  ->  expr_no_commas . '^' expr_no_commas   (rule 64)
    expr_no_commas  ->  expr_no_commas . ANDAND expr_no_commas   (rule 65)
    expr_no_commas  ->  expr_no_commas . OROR expr_no_commas   (rule 66)
    expr_no_commas  ->  expr_no_commas . '?' xexpr ':' expr_no_commas   (rule 67)
    expr_no_commas  ->  expr_no_commas . '=' expr_no_commas   (rule 68)
    expr_no_commas  ->  expr_no_commas . ASSIGN expr_no_commas   (rule 69)
    component_declarator  ->  declarator ':' expr_no_commas .   (rule 179)

    ASSIGN	shift, and go to state 135
    '=' 	shift, and go to state 136
    '?' 	shift, and go to state 137
    OROR	shift, and go to state 138
    ANDAND	shift, and go to state 139
    '|' 	shift, and go to state 140
    '^' 	shift, and go to state 141
    '&' 	shift, and go to state 142
    EQCOMPARE	shift, and go to state 143
    ARITHCOMPARE	shift, and go to state 144
    LSHIFT	shift, and go to state 145
    RSHIFT	shift, and go to state 146
    '+' 	shift, and go to state 147
    '-' 	shift, and go to state 148
    '*' 	shift, and go to state 149
    '/' 	shift, and go to state 150
    '%' 	shift, and go to state 151

    $default	reduce using rule 179 (component_declarator)



state 385

    components  ->  components ',' component_declarator .   (rule 177)

    $default	reduce using rule 177 (components)



state 386

    compstmt  ->  '{' pushlevel error '}' .   (rule 213)

    $default	reduce using rule 213 (compstmt)



state 387

    simple_if  ->  IF '(' . expr ')' @16 stmt   (rule 216)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr	go to state 417
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 388

    stmt  ->  WHILE @18 . '(' expr ')' @19 stmt   (rule 224)

    '(' 	shift, and go to state 418



state 389

    stmt  ->  DO @20 . stmt WHILE @21 '(' expr ')' ';'   (rule 227)

    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 419



state 390

    stmt  ->  FOR '(' . xexpr ';' @22 xexpr ';' @23 xexpr ')' @24 stmt   (rule 231)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    $default	reduce using rule 251 (xexpr)

    unop	go to state 72
    expr	go to state 218
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    xexpr	go to state 420



state 391

    stmt  ->  SWITCH '(' . expr ')' @25 stmt   (rule 233)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr	go to state 421
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 392

    stmt  ->  CASE expr . ':' @26 stmt   (rule 235)

    ':' 	shift, and go to state 422



state 393

    stmt  ->  DEFAULT ':' . @27 stmt   (rule 237)

    $default	reduce using rule 236 (@27)

    @27 	go to state 423



state 394

    stmt  ->  BREAK ';' .   (rule 238)

    $default	reduce using rule 238 (stmt)



state 395

    stmt  ->  CONTINUE ';' .   (rule 239)

    $default	reduce using rule 239 (stmt)



state 396

    stmt  ->  RETURN ';' .   (rule 240)

    $default	reduce using rule 240 (stmt)



state 397

    stmt  ->  RETURN expr . ';'   (rule 241)

    ';' 	shift, and go to state 424



state 398

    stmt  ->  GOTO identifier . ';'   (rule 245)

    ';' 	shift, and go to state 425



state 399

    maybe_type_qual  ->  TYPE_QUAL .   (rule 250)

    $default	reduce using rule 250 (maybe_type_qual)



state 400

    stmt  ->  ASM maybe_type_qual . '(' string ')' ';'   (rule 242)
    stmt  ->  ASM maybe_type_qual . '(' string ':' asm_operands ')' ';'   (rule 243)
    stmt  ->  ASM maybe_type_qual . '(' string ':' asm_operands ':' asm_operands ')' ';'   (rule 244)

    '(' 	shift, and go to state 426



state 401

    stmt  ->  identifier ':' . @28 stmt   (rule 247)

    $default	reduce using rule 246 (@28)

    @28 	go to state 427



state 402

    stmt  ->  expr ';' .   (rule 218)

    $default	reduce using rule 218 (stmt)



state 403

    stmts  ->  stmts . stmt   (rule 203)
    stmts  ->  stmts . errstmt   (rule 204)
    xstmts  ->  stmts .   (rule 206)

    error	shift, and go to state 178
    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    '}' 	[reduce using rule 206 (xstmts)]

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    errstmt	go to state 406
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 407



state 404

    compstmt  ->  '{' pushlevel decls xstmts . '}'   (rule 212)

    '}' 	shift, and go to state 428



state 405

    compstmt  ->  '{' pushlevel stmts '}' .   (rule 214)

    $default	reduce using rule 214 (compstmt)



state 406

    stmts  ->  stmts errstmt .   (rule 204)

    $default	reduce using rule 204 (stmts)



state 407

    stmts  ->  stmts stmt .   (rule 203)

    $default	reduce using rule 203 (stmts)



state 408

    stmt  ->  simple_if ELSE . @17 stmt   (rule 220)

    $default	reduce using rule 219 (@17)

    @17 	go to state 429



state 409

    initlist  ->  initlist ',' . init   (rule 134)
    maybecomma  ->  ',' .   (rule 168)

    error	shift, and go to state 329
    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 330

    '}' 	reduce using rule 168 (maybecomma)

    unop	go to state 72
    expr_no_commas	go to state 331
    primary	go to state 76
    string	go to state 77
    init	go to state 430



state 410

    expr_no_commas  ->  '(' typename ')' '{' initlist maybecomma . '}'   (rule 48)

    '}' 	shift, and go to state 431



state 411

    parm_declarator  ->  parm_declarator . '(' parmlist_or_identifiers   (rule 143)
    parm_declarator  ->  parm_declarator . '[' expr ']'   (rule 144)
    parm_declarator  ->  parm_declarator . '[' ']'   (rule 145)
    parm_declarator  ->  '*' type_quals parm_declarator .   (rule 146)

    '(' 	shift, and go to state 371
    '[' 	shift, and go to state 372

    '(' 	[reduce using rule 146 (parm_declarator)]
    '[' 	[reduce using rule 146 (parm_declarator)]
    $default	reduce using rule 146 (parm_declarator)



state 412

    parm_declarator  ->  parm_declarator '(' parmlist_or_identifiers .   (rule 143)

    $default	reduce using rule 143 (parm_declarator)



state 413

    parm_declarator  ->  parm_declarator '[' ']' .   (rule 145)

    $default	reduce using rule 145 (parm_declarator)



state 414

    parm_declarator  ->  parm_declarator '[' expr . ']'   (rule 144)

    ']' 	shift, and go to state 432



state 415

    init  ->  '{' initlist '}' .   (rule 130)

    $default	reduce using rule 130 (init)



state 416

    init  ->  '{' initlist ',' . '}'   (rule 131)
    initlist  ->  initlist ',' . init   (rule 134)

    error	shift, and go to state 329
    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '}' 	shift, and go to state 433
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 330

    unop	go to state 72
    expr_no_commas	go to state 331
    primary	go to state 76
    string	go to state 77
    init	go to state 430



state 417

    simple_if  ->  IF '(' expr . ')' @16 stmt   (rule 216)

    ')' 	shift, and go to state 434



state 418

    stmt  ->  WHILE @18 '(' . expr ')' @19 stmt   (rule 224)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr	go to state 435
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 419

    stmt  ->  DO @20 stmt . WHILE @21 '(' expr ')' ';'   (rule 227)

    WHILE	shift, and go to state 436



state 420

    stmt  ->  FOR '(' xexpr . ';' @22 xexpr ';' @23 xexpr ')' @24 stmt   (rule 231)

    ';' 	shift, and go to state 437



state 421

    stmt  ->  SWITCH '(' expr . ')' @25 stmt   (rule 233)

    ')' 	shift, and go to state 438



state 422

    stmt  ->  CASE expr ':' . @26 stmt   (rule 235)

    $default	reduce using rule 234 (@26)

    @26 	go to state 439



state 423

    stmt  ->  DEFAULT ':' @27 . stmt   (rule 237)

    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 440



state 424

    stmt  ->  RETURN expr ';' .   (rule 241)

    $default	reduce using rule 241 (stmt)



state 425

    stmt  ->  GOTO identifier ';' .   (rule 245)

    $default	reduce using rule 245 (stmt)



state 426

    stmt  ->  ASM maybe_type_qual '(' . string ')' ';'   (rule 242)
    stmt  ->  ASM maybe_type_qual '(' . string ':' asm_operands ')' ';'   (rule 243)
    stmt  ->  ASM maybe_type_qual '(' . string ':' asm_operands ':' asm_operands ')' ';'   (rule 244)

    STRING	shift, and go to state 56

    string	go to state 441



state 427

    stmt  ->  identifier ':' @28 . stmt   (rule 247)

    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 442



state 428

    compstmt  ->  '{' pushlevel decls xstmts '}' .   (rule 212)

    $default	reduce using rule 212 (compstmt)



state 429

    stmt  ->  simple_if ELSE @17 . stmt   (rule 220)

    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 443



state 430

    initlist  ->  initlist ',' init .   (rule 134)

    $default	reduce using rule 134 (initlist)



state 431

    expr_no_commas  ->  '(' typename ')' '{' initlist maybecomma '}' .   (rule 48)

    $default	reduce using rule 48 (expr_no_commas)



state 432

    parm_declarator  ->  parm_declarator '[' expr ']' .   (rule 144)

    $default	reduce using rule 144 (parm_declarator)



state 433

    init  ->  '{' initlist ',' '}' .   (rule 131)

    $default	reduce using rule 131 (init)



state 434

    simple_if  ->  IF '(' expr ')' . @16 stmt   (rule 216)

    $default	reduce using rule 215 (@16)

    @16 	go to state 444



state 435

    stmt  ->  WHILE @18 '(' expr . ')' @19 stmt   (rule 224)

    ')' 	shift, and go to state 445



state 436

    stmt  ->  DO @20 stmt WHILE . @21 '(' expr ')' ';'   (rule 227)

    $default	reduce using rule 226 (@21)

    @21 	go to state 446



state 437

    stmt  ->  FOR '(' xexpr ';' . @22 xexpr ';' @23 xexpr ')' @24 stmt   (rule 231)

    $default	reduce using rule 228 (@22)

    @22 	go to state 447



state 438

    stmt  ->  SWITCH '(' expr ')' . @25 stmt   (rule 233)

    $default	reduce using rule 232 (@25)

    @25 	go to state 448



state 439

    stmt  ->  CASE expr ':' @26 . stmt   (rule 235)

    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 449



state 440

    stmt  ->  DEFAULT ':' @27 stmt .   (rule 237)

    $default	reduce using rule 237 (stmt)



state 441

    string  ->  string . STRING   (rule 84)
    stmt  ->  ASM maybe_type_qual '(' string . ')' ';'   (rule 242)
    stmt  ->  ASM maybe_type_qual '(' string . ':' asm_operands ')' ';'   (rule 243)
    stmt  ->  ASM maybe_type_qual '(' string . ':' asm_operands ':' asm_operands ')' ';'   (rule 244)

    STRING	shift, and go to state 121
    ':' 	shift, and go to state 450
    ')' 	shift, and go to state 451



state 442

    stmt  ->  identifier ':' @28 stmt .   (rule 247)

    $default	reduce using rule 247 (stmt)



state 443

    stmt  ->  simple_if ELSE @17 stmt .   (rule 220)

    $default	reduce using rule 220 (stmt)



state 444

    simple_if  ->  IF '(' expr ')' @16 . stmt   (rule 216)

    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 452



state 445

    stmt  ->  WHILE @18 '(' expr ')' . @19 stmt   (rule 224)

    $default	reduce using rule 223 (@19)

    @19 	go to state 453



state 446

    stmt  ->  DO @20 stmt WHILE @21 . '(' expr ')' ';'   (rule 227)

    '(' 	shift, and go to state 454



state 447

    stmt  ->  FOR '(' xexpr ';' @22 . xexpr ';' @23 xexpr ')' @24 stmt   (rule 231)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    $default	reduce using rule 251 (xexpr)

    unop	go to state 72
    expr	go to state 218
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    xexpr	go to state 455



state 448

    stmt  ->  SWITCH '(' expr ')' @25 . stmt   (rule 233)

    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 456



state 449

    stmt  ->  CASE expr ':' @26 stmt .   (rule 235)

    $default	reduce using rule 235 (stmt)



state 450

    stmt  ->  ASM maybe_type_qual '(' string ':' . asm_operands ')' ';'   (rule 243)
    stmt  ->  ASM maybe_type_qual '(' string ':' . asm_operands ':' asm_operands ')' ';'   (rule 244)

    STRING	shift, and go to state 457

    $default	reduce using rule 253 (asm_operands)

    asm_operands	go to state 458
    nonnull_asm_operands	go to state 459
    asm_operand	go to state 460



state 451

    stmt  ->  ASM maybe_type_qual '(' string ')' . ';'   (rule 242)

    ';' 	shift, and go to state 461



state 452

    simple_if  ->  IF '(' expr ')' @16 stmt .   (rule 216)

    $default	reduce using rule 216 (simple_if)



state 453

    stmt  ->  WHILE @18 '(' expr ')' @19 . stmt   (rule 224)

    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 462



state 454

    stmt  ->  DO @20 stmt WHILE @21 '(' . expr ')' ';'   (rule 227)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr	go to state 463
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 455

    stmt  ->  FOR '(' xexpr ';' @22 xexpr . ';' @23 xexpr ')' @24 stmt   (rule 231)

    ';' 	shift, and go to state 464



state 456

    stmt  ->  SWITCH '(' expr ')' @25 stmt .   (rule 233)

    $default	reduce using rule 233 (stmt)



state 457

    asm_operand  ->  STRING . '(' expr ')'   (rule 257)

    '(' 	shift, and go to state 465



state 458

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands . ')' ';'   (rule 243)
    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands . ':' asm_operands ')' ';'   (rule 244)

    ':' 	shift, and go to state 466
    ')' 	shift, and go to state 467



state 459

    asm_operands  ->  nonnull_asm_operands .   (rule 254)
    nonnull_asm_operands  ->  nonnull_asm_operands . ',' asm_operand   (rule 256)

    ',' 	shift, and go to state 468

    $default	reduce using rule 254 (asm_operands)



state 460

    nonnull_asm_operands  ->  asm_operand .   (rule 255)

    $default	reduce using rule 255 (nonnull_asm_operands)



state 461

    stmt  ->  ASM maybe_type_qual '(' string ')' ';' .   (rule 242)

    $default	reduce using rule 242 (stmt)



state 462

    stmt  ->  WHILE @18 '(' expr ')' @19 stmt .   (rule 224)

    $default	reduce using rule 224 (stmt)



state 463

    stmt  ->  DO @20 stmt WHILE @21 '(' expr . ')' ';'   (rule 227)

    ')' 	shift, and go to state 469



state 464

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' . @23 xexpr ')' @24 stmt   (rule 231)

    $default	reduce using rule 229 (@23)

    @23 	go to state 470



state 465

    asm_operand  ->  STRING '(' . expr ')'   (rule 257)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    unop	go to state 72
    expr	go to state 471
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77



state 466

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' . asm_operands ')' ';'   (rule 244)

    STRING	shift, and go to state 457

    $default	reduce using rule 253 (asm_operands)

    asm_operands	go to state 472
    nonnull_asm_operands	go to state 459
    asm_operand	go to state 460



state 467

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ')' . ';'   (rule 243)

    ';' 	shift, and go to state 473



state 468

    nonnull_asm_operands  ->  nonnull_asm_operands ',' . asm_operand   (rule 256)

    STRING	shift, and go to state 457

    asm_operand	go to state 474



state 469

    stmt  ->  DO @20 stmt WHILE @21 '(' expr ')' . ';'   (rule 227)

    ';' 	shift, and go to state 475



state 470

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' @23 . xexpr ')' @24 stmt   (rule 231)

    IDENTIFIER	shift, and go to state 58
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71

    $default	reduce using rule 251 (xexpr)

    unop	go to state 72
    expr	go to state 218
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    xexpr	go to state 476



state 471

    asm_operand  ->  STRING '(' expr . ')'   (rule 257)

    ')' 	shift, and go to state 477



state 472

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands . ')' ';'   (rule 244)

    ')' 	shift, and go to state 478



state 473

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ')' ';' .   (rule 243)

    $default	reduce using rule 243 (stmt)



state 474

    nonnull_asm_operands  ->  nonnull_asm_operands ',' asm_operand .   (rule 256)

    $default	reduce using rule 256 (nonnull_asm_operands)



state 475

    stmt  ->  DO @20 stmt WHILE @21 '(' expr ')' ';' .   (rule 227)

    $default	reduce using rule 227 (stmt)



state 476

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' @23 xexpr . ')' @24 stmt   (rule 231)

    ')' 	shift, and go to state 479



state 477

    asm_operand  ->  STRING '(' expr ')' .   (rule 257)

    $default	reduce using rule 257 (asm_operand)



state 478

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ')' . ';'   (rule 244)

    ';' 	shift, and go to state 480



state 479

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' @23 xexpr ')' . @24 stmt   (rule 231)

    $default	reduce using rule 230 (@24)

    @24 	go to state 481



state 480

    stmt  ->  ASM maybe_type_qual '(' string ':' asm_operands ':' asm_operands ')' ';' .   (rule 244)

    $default	reduce using rule 244 (stmt)



state 481

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' @23 xexpr ')' @24 . stmt   (rule 231)

    IDENTIFIER	shift, and go to state 342
    TYPENAME	shift, and go to state 27
    CONSTANT	shift, and go to state 60
    STRING	shift, and go to state 56
    SIZEOF	shift, and go to state 61
    IF  	shift, and go to state 344
    WHILE	shift, and go to state 345
    DO  	shift, and go to state 346
    FOR 	shift, and go to state 347
    SWITCH	shift, and go to state 348
    CASE	shift, and go to state 349
    DEFAULT	shift, and go to state 350
    BREAK	shift, and go to state 351
    CONTINUE	shift, and go to state 352
    RETURN	shift, and go to state 353
    GOTO	shift, and go to state 354
    ASM 	shift, and go to state 355
    ALIGNOF	shift, and go to state 62
    '&' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '-' 	shift, and go to state 65
    '*' 	shift, and go to state 66
    PLUSPLUS	shift, and go to state 67
    MINUSMINUS	shift, and go to state 68
    '(' 	shift, and go to state 69
    ';' 	shift, and go to state 356
    '~' 	shift, and go to state 70
    '!' 	shift, and go to state 71
    '{' 	shift, and go to state 212

    identifier	go to state 357
    unop	go to state 72
    expr	go to state 358
    nonnull_exprlist	go to state 74
    expr_no_commas	go to state 75
    primary	go to state 76
    string	go to state 77
    compstmt	go to state 361
    simple_if	go to state 362
    stmt	go to state 482



state 482

    stmt  ->  FOR '(' xexpr ';' @22 xexpr ';' @23 xexpr ')' @24 stmt .   (rule 231)

    $default	reduce using rule 231 (stmt)



state 483

    $   	go to state 484



state 484

    $   	go to state 485



state 485

    $default	accept
